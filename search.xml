<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[编程函数（二）]]></title>
      <url>%2F2017%2F05%2F13%2Fbianchenghanshu2%2F</url>
      <content type="text"><![CDATA[函数返回值：函数的执行结果返回值： 显示使用echo或print命令输出； 函数体中调用的命令的执行结果； 函数的退出状态码： 默认取决与函数体中执行的最后一条命令的退出状态码 自定义：return 函数可以接受参数： 传递参数给函数： 在函数体当中，可以使用$1 $2 ...引用传递给函数的参数 在调用函数时，在函数名后面以空白符分隔给定参数列表即可，例如testfunc arg1 arg2 arg3 示例：添加十个用户， 添加用户的功能使用函数实现，用户名作为参数传输给函数123456789101112131415161718192021222324#!/bin/bash## 5 user existsadduser()&#123; if id $1 &amp;&gt; /dev/null;then return 5 else useradd $1 retval=$? return $retval fi&#125;for i in &#123;1..10&#125;;do adduser $&#123;1&#125;$&#123;i&#125; retval=$? if [ $retval -eq 0 ];then echo &quot;Add user $&#123;1&#125;$&#123;i&#125; finished&quot; elif [ $retval -eq 5];then echo &quot;user $&#123;1&#125;$&#123;i&#125; exists&quot; else echo &quot;Unkown Error&quot; fidone 变量作用域：局部变量：作用范围是函数的生命周期；在函数结束时被自动销毁 定义局部变量的方法：local VARIABLE=VALUE 本地变量：作用域是运行脚本的shell进程的生命周期；因此，其作用范围为当前shell脚本程序文件 示例 12345678910#！/bin/bash#name=tomsetname&#123; local name=jerry echo &quot;Function:$name&quot;&#125;setnameecho &quot;shell:$name&quot; 函数递归：函数直接或间接调用自身 阶乘示例 123456789fact()&#123; if [ $1 -eq 0 -o $1 -eq 1 ];then echo 1 else echo $[ $1*$(fact $[$1-1])] fi&#125;fact $1 斐波那契数列示例 123456789101112131415#!/bin/bash# fab() &#123; if [ $1 -eq 1 ];then echo 1 elif [ $2 -eq 2 ];then echo 1 else echo $[$(fab $[$1-1])+$(fab $[$1-2])] fi &#125; for i in $&#123;seq 1 $1&#125;;do fab $i done]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[编程函数（一）]]></title>
      <url>%2F2017%2F05%2F12%2Fbianchenghanshu%2F</url>
      <content type="text"><![CDATA[编程函数case 语句多分支if语句 if CONDITION1；then 分支1 elif CONDITION2 ；then 分支2 else CONDITION ；then 分支n fi 示例1：显示一个菜单给用户 cpu）display cpu information disk）display disk information quit）quit *） 要求： 提示用户给出自己的选择 正确的选择则给出相应的信息；否则提示重新选择正确的选项 123456789101112131415161718192021222324#!/bin/bash#cat&lt;&lt;EOFcpu）display cpu informationdisk）display disk informationquit）quit===============================EOFread -p &quot;请输入你的选项&quot; optionwhile [&quot;$option&quot; != &quot;cpu&quot; -a &quot;$option&quot; != &quot;disk&quot; -a &quot;$option&quot; != &quot;quit&quot;] echo &quot;请输入：cpu、disk、quit&quot; read -p &quot;请重新输入一次选项：&quot; optiondoneif [ &quot;$option&quot; == &quot;cpu&quot; ];then lscpuelif [ &quot;$option&quot; == &quot;disk&quot; ];then fdisk -l /dev/[hs]d[a-z]else echo &quot;quit&quot; exit 0fi case语句的语法格式： case $VARAIBLE in PART1) 分支1 ;; PART2) 分支2 ;; *) 分支n ;; esac case示例：1234567891011121314#!/bin/bash#case $option incpu) lscpu ;;disk) fdisk -l /dev/[hs]d[a-z];;*) echo &quot;quit&quot; exit 0 ;;case case支持glob风格的通配符 *任意长度的任意赐福 ？任意单个字符 []范围内任意单个字符 a|b或 示例：写一个服务框架脚本 此脚本可接收start、stop、restart、status、四个参数之一 如果参数非此四者，则提示使用帮助后退出 satrt，则创建lockfile，并显示启动； stop，则删除lockfile，并显示停止； restart，则先删除此文件再创建此文件，此后显示重启完成， status，如果lockfile存在，则显示running，否则显示为stoping 123456789101112131415161718192021222324252627282930313233343536#!/bin/bash#chkconfig: - 50 50#description：test service scriptprog=$&#123;basename $0&#125;lockfile=/var/lock/subsys/$progcase $1 instart) if [ -f $lockfile ];then echo &quot;$prog is running yet&quot; else touch $lockfile [ $? -eq 0 ] &amp;&amp; echo &quot;start $prog finshed&quot; fi ;;stop) if [ -f $lockfile ];then rm -f $lockfile [ $? -eq 0 ] &amp;&amp; echo &quot;stop $prog finshed&quot;esle touch -f $lockfile echo &quot;start $prog finshed&quot;fi;;statu) if [ -f $locakfile ];then echo &quot;$prog is running&quot; else echo &quot;$prog is stopped&quot; fi ;;*) echo &quot;usage :$prog &#123;start|stop|restart|status&#125;&quot; exit 1 ;;esac 函数：function 过程式编程：代码重用 模块化编程 结构化编程 把一段独立功能的代码当做一个整体并为之去一个名字；命名的代码段，此即为函数； 注意：定义函数的代码段不会自动执行，在调用时执行；所谓调用函数，在代码中给定函数名即可； 函数名出现的任意位置，在代码执行时，都会被自动替换为函数代码； 语法一： function f_name { 函数体 } 语法二： f_name() { 函数体 } 函数的生命周期：每次被调用时创建，返回时终止； 其状态返回结果为函数体中运行的最后一条命令的状态结果 自定义状态返回值，需要使用return return [0-255] 0:成功 1-255：失败 示例1：给定一个用户名，取得用户的ID号和默认shell123456789101112#!/bin/bash#username=$1userinfo() &#123; if id &quot;$username&quot; &amp;&gt; /dev/null ;then grep &quot;^$\&gt;&quot; | cut -d: -f3,7 else echo &quot;No such user&quot; fi&#125;userinfo 示例2：服务脚本框架 #!/bin/bash #chkconfig: - 50 50 #description：test service script prog=${basename $0} lockfile=/var/lock/subsys/$prog start(){ if [ -f $lockfile ];then echo &quot;$prog is running yet&quot; else touch $lockfile [ $? -eq 0 ] &amp;&amp; echo &quot;start $prog finshed&quot; fi } stop() { if [ -f $lockfile ];then rm -f $lockfile [ $? -eq 0 ] &amp;&amp; echo &quot;stop $prog finshed&quot; esle touch -f $lockfile echo &quot;start $prog finshed&quot; fi } statu() { if [ -f $locakfile ];then echo &quot;$prog is running&quot; else echo &quot;$prog is stopped&quot; fi } usage() { echo &quot;Usage:$prog {start|stop|restart|status}&quot; } case $1 in start) start ;; stop) stop ;; status) status ;; *) usage exit ;; esac]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[grub.conf格式]]></title>
      <url>%2F2017%2F05%2F11%2Fgrub-conf%2F</url>
      <content type="text"><![CDATA[grub.conf格式生成时间是安装系统的时间 default=0 timeout=3 password --md5 密码 进入单用户时需要输入口令，保护所有内核版本系统grub-md5-crypt生成md5加密密码 --encrypted grub-crypt生成sha512加密密码 title leessangzs OS root （hd0,0）根目录的路径，但是操作系统启动一开始是找boot的，所以此处写boot的路径hd表示硬盘，0表示第一个硬盘，0表示第一个分区 kernel /vmlinuz initrd /initramfs password 密码 进入此系统时需要的输入口令，只对当前内核版本有效 实验：删除grub.conf，恢复 进入命令行界面写两行 kernel行和initrd行 kernel /vmlinuz root=/dev/sda initrd /initrams 实验：删除grub，恢复 救援模式 切根 grub-install /dev/sda sync vim grub.conf default=0 timeout=3 title leessangz OS kernel /vmlinuz root=/dev/sda initrd /initramfs 实验：删除boot，恢复 boot里有 vmlinuz initramfs.img grub.conf 选用：rpm -ivh /mnt/cdrom/Packages/Kernel.XXXrpm 解决vmlinuz 救援模式去安装盘里拷一份vmlinuz放到boot下 解决initramfs.img mkinitrd /boot/initrdramfs.img `uname -r` sync同步一下 解决grub文件夹 grub-install /dev/sda 解决grub.conf vim grub.conf default=0 timeout=3 title leessangz OS kernel /vmlinuz root=/dev/sdax initrd /initramfs]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[实验：解决启动等级为6时无限重启]]></title>
      <url>%2F2017%2F05%2F03%2Fchange-open-level%2F</url>
      <content type="text"><![CDATA[实验：解决启动等级为6时无限重启 首先把/etc/inittab文件中最后一行启动等级改为6。 保存后重启发现系统无限重启。 解决：首先进入系统启动倒数界面。摁任意键。 进入列表界面后摁a键。 在命令行最后输入数字3.设置为当前启动等级为多用户模式。 进入系统以后再重新修改/etc/inittab文件。将启动等级恢复为3。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[实验：忘记登录密码，单用户模式下修改密码]]></title>
      <url>%2F2017%2F05%2F03%2Fchangepasswd%2F</url>
      <content type="text"><![CDATA[实验：忘记登录密码，单用户模式下修改密码进入系统启动倒数界面摁任意键。 进入列表界面摁a键。 在命令行末尾输入single或者数字1 回车后进入单用户模式，修改密码。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[每天一个linux命令--locate]]></title>
      <url>%2F2017%2F04%2F25%2Fevery-day-linux-command18-locate%2F</url>
      <content type="text"><![CDATA[每天一个linux命令–locate文章转载自博客园，作者peida。本文仅作为自用参考，请勿转载。 locate 让使用者可以很快速的搜寻档案系统内是否有指定的档案。其方法是先建立一个包括系统内所有档案名称及路径的数据库，之后当寻找时就只需查询这个数据库，而不必实际深入档案系统之中了。在一般的 distribution 之中，数据库的建立都被放在 crontab 中自动执行。 1．命令格式： Locate [选择参数] [样式] 2．命令功能： locate命令可以在搜寻数据库时快速找到档案，数据库由updatedb程序来更新，updatedb是由cron daemon周期性建立的， locate命令在搜寻数据库时比由整个由硬盘资料来搜寻资料来得快，但较差劲的是locate所找到的档案若是最近才建立或 刚更名的，可能会找不到，在内定值中，updatedb每天会跑一次，可以由修改crontab来更新设定值。(etc/crontab) locate指定用在搜寻符合条件的档案，它会去储存档案与目录名称的数据库内，寻找合乎范本样式条件的档案或目录录， 可以使用特殊字元（如”*” 或”?”等）来指定范本样式，如指定范本为kcpa*ner, locate会找出所有起始字串为kcpa且 结尾为ner的档案或目录，如名称为kcpartner若目录录名称为kcpa_ner则会列出该目录下包括 子目录在内的所有档案。 locate指令和find找寻档案的功能类似，但locate是透过update程序将硬盘中的所有档案和目录资料先建立一个索引数据库， 在 执行loacte时直接找该索引，查询速度会较快，索引数据库一般是由操作系统管理，但也可以直接下达update强迫系统立 即修改索引数据库。 3．命令参数： -e 将排除在寻找的范围之外。 -1 如果 是 1．则启动安全模式。在安全模式下，使用者不会看到权限无法看到的档案。这会始速度减慢，因为 locate 必须至实际的档案系统中取得档案的权限资料。 -f 将特定的档案系统排除在外，例如我们没有到理要把 proc 档案系统中的档案放在资料库中。 -q 安静模式，不会显示任何错误讯息。 -n 至多显示 n个输出。 -r 使用正规运算式 做寻找的条件。 -o 指定资料库存的名称。 -d 指定资料库的路径 -h 显示辅助讯息 -V 显示程式的版本讯息 4．使用实例： 实例1:查找和pwd相关的所有文件 命令： locate pwd 输出：12345678910111213141516171819202122232425262728293031peida-VirtualBox ~ # locate pwd/bin/pwd/etc/.pwd.lock/sbin/unix_chkpwd/usr/bin/pwdx/usr/include/pwd.h/usr/lib/python2.7/dist-packages/twisted/python/fakepwd.py/usr/lib/python2.7/dist-packages/twisted/python/fakepwd.pyc/usr/lib/python2.7/dist-packages/twisted/python/test/test_fakepwd.py/usr/lib/python2.7/dist-packages/twisted/python/test/test_fakepwd.pyc/usr/lib/syslinux/pwd.c32/usr/share/help/C/empathy/irc-join-pwd.page/usr/share/help/ca/empathy/irc-join-pwd.page/usr/share/help/cs/empathy/irc-join-pwd.page/usr/share/help/de/empathy/irc-join-pwd.page/usr/share/help/el/empathy/irc-join-pwd.page 实例2： 搜索etc目录下所有以sh开头的文件 命令： locate /etc/sh 输出：123456789peida-VirtualBox ~ # locate /etc/sh/etc/shadow/etc/shadow-/etc/shellspeida-VirtualBox ~ # 实例3：搜索etc目录下，所有以m开头的文件 命令： locate /etc/m 输出：12345678910111213peida-VirtualBox ~ # locate /etc/m/etc/magic/etc/magic.mime/etc/mailcap/etc/mailcap.order/etc/manpath.config/etc/mate-settings-daemon]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[每天一个linux命令--whereis]]></title>
      <url>%2F2017%2F04%2F24%2Fevery-day-linux-command17-whereis%2F</url>
      <content type="text"><![CDATA[每天一个linux命令–whereis文章转载自博客园，作者peida。本文仅作为自用参考，请勿转载。 whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。 和find相比，whereis查找的速度非常快，这是因为linux系统会将 系统内的所有文件都记录在一个数据库文件中，当使用whereis和下面即将介绍的locate时，会从数据库中查找数据，而不是像find命令那样，通 过遍历硬盘来查找，效率自然会很高。 但是该数据库文件并不是实时更新，默认情况下时一星期更新一次，因此，我们在用whereis和locate 查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。 1．命令格式： whereis [-bmsu] [BMS 目录名 -f ] 文件名 2．命令功能： whereis命令是定位可执行文件、源代码文件、帮助文件在文件系统中的位置。这些文件的属性应属于原始代码，二进制文件， 或是帮助文件。whereis 程序还具有搜索源代码、指定备用搜索路径和搜索不寻常项的能力。 3．命令参数： -b 定位可执行文件。 -m 定位帮助文件。 -s 定位源代码文件。 -u 搜索默认路径下除可执行文件、源代码文件、帮助文件以外的其它文件。 -B 指定搜索可执行文件的路径。 -M 指定搜索帮助文件的路径。 -S 指定搜索源代码文件的路径。 4．使用实例： 实例1：将和**文件相关的文件都查找出来 命令： whereis svn 输出：1234567[root@localhost ~]# whereis tomcattomcat:[root@localhost ~]# whereis svnsvn: /usr/bin/svn /usr/local/svn /usr/share/man/man1/svn.1.gz 说明： tomcat没安装，找不出来，svn安装找出了很多相关文件 实例2：只将二进制文件 查找出来 命令： whereis -b svn 输出：12345678910111213[root@localhost ~]# whereis -b svnsvn: /usr/bin/svn /usr/local/svn[root@localhost ~]# whereis -m svnsvn: /usr/share/man/man1/svn.1.gz[root@localhost ~]# whereis -s svnsvn:[root@localhost ~]# 说明： whereis -m svn 查出说明文档路径，whereis -s svn 找source源文件。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Home目录迁移]]></title>
      <url>%2F2017%2F04%2F24%2Fmove-home%2F</url>
      <content type="text"><![CDATA[迁移Home目录到新分区1.备份Home目录12[root@localhost ~]# mkdir /bak[root@localhost ~]# cp -a /home /bak/ 2.创建Home所需要迁移到的新分区1234567891011121314151617181920212223242526272829[root@localhost /]# fdisk /dev/sdbDevice contains neither a valid DOS partition table, nor Sun, SGI or OSF disklabelBuilding a new DOS disklabel with disk identifier 0xc32bdfe3.Changes will remain in memory only, until you decide to write them.After that, of course, the previous content won&apos;t be recoverable.Warning: invalid flag 0x0000 of partition table 4 will be corrected by w(rite)WARNING: DOS-compatible mode is deprecated. It&apos;s strongly recommended to switch off the mode (command &apos;c&apos;) and change display units to sectors (command &apos;u&apos;).Command (m for help): 输入：nCommand action e extended p primary partition (1-4) 输入：pPartition number (1-4): 1 输入：1First cylinder (1-2610, default 1): Using default value 1Last cylinder, +cylinders or +size&#123;K,M,G&#125; (1-2610, default 2610): +5GCommand (m for help): wThe partition table has been altered!Calling ioctl() to re-read partition table.Syncing disks. 实验环境为Home分配一个5G新分区sdb1。 3.格式化新分区1234567891011121314151617181920212223[root@localhost /]# mkfs.ext4 /dev/sdb1mke2fs 1.41.12 (17-May-2010)Filesystem label=OS type: LinuxBlock size=4096 (log=2)Fragment size=4096 (log=2)Stride=0 blocks, Stripe width=0 blocks328656 inodes, 1313305 blocks65665 blocks (5.00%) reserved for the super userFirst data block=0Maximum filesystem blocks=134637158441 block groups32768 blocks per group, 32768 fragments per group8016 inodes per groupSuperblock backups stored on blocks: 32768, 98304, 163840, 229376, 294912, 819200, 884736Writing inode tables: done Creating journal (32768 blocks): doneWriting superblocks and filesystem accounting information: doneThis filesystem will be automatically checked every 31 mounts or180 days, whichever comes first. Use tune2fs -c or -i to override. 这里选择ext4的文件系统 4.将新分区临时挂载并在分区上新建Home目录12[root@localhost /]# mkdir /mnt/home[root@localhost /]# mount /dev/sdb1 /mnt/home 5.将系统改为单用户模式1[root@localhost /]# init 1 为了防止其他用户在迁移过程中对Home目录进行修改。 6.把Hmoe目录下的所有文件，拷贝到新建的Home目录中123456789[root@localhost home]# cp -av /home/* /mnt/home/`/home/user1&apos; -&gt; `/mnt/home/user1&apos;`/home/user1/.bash_logout&apos; -&gt; `/mnt/home/user1/.bash_logout&apos;`/home/user1/.bashrc&apos; -&gt; `/mnt/home/user1/.bashrc&apos;`/home/user1/.mozilla&apos; -&gt; `/mnt/home/user1/.mozilla&apos;`/home/user1/.mozilla/extensions&apos; -&gt; `/mnt/home/user1/.mozilla/extensions&apos;`/home/user1/.mozilla/plugins&apos; -&gt; `/mnt/home/user1/.mozilla/plugins&apos;`/home/user1/.bash_profile&apos; -&gt; `/mnt/home/user1/.bash_profile&apos;`/home/user1/.gnome2&apos; -&gt; `/mnt/home/user1/.gnome2&apos; 做这步操作之前要确保系统中已经创件过新用户，不然Home为空。 7.将原有Home目录删除12[root@localhost home]# rm -rf /home/*[root@localhost home]# 8.修改配置文件。使Home目录开机自动挂载到新分区首先用blkid命令查询需要挂载的分区的UUID12345678[root@localhost home]# blkid/dev/sda1: UUID=&quot;1b111728-c1d4-4814-bc8d-68376790c00e&quot; TYPE=&quot;ext4&quot; /dev/sda2: UUID=&quot;ufu0Lv-xfQQ-zs4y-dhsz-4tae-btjc-kBrhoM&quot; TYPE=&quot;LVM2_member&quot; /dev/sdb1: UUID=&quot;9220e3b8-ac6f-4da5-883d-e7b20a8d1400&quot; TYPE=&quot;ext4&quot; /dev/mapper/vg0-root: UUID=&quot;12e97ef4-2c8a-4604-a3e4-d831c47117ef&quot; TYPE=&quot;ext4&quot; /dev/mapper/vg0-swap: UUID=&quot;425afff3-9081-4cfd-97f4-d7f4ba3438b1&quot; TYPE=&quot;swap&quot; /dev/mapper/vg0-usr: UUID=&quot;a2310e89-94ab-417b-aa07-2758157ad154&quot; TYPE=&quot;ext4&quot; /dev/mapper/vg0-var: UUID=&quot;3ddb530b-4aed-44f5-8937-83bb3158dce2&quot; TYPE=&quot;ext4&quot; 然后修改配置文件fstab，在最后一行添加。1234567891011121314151617## /etc/fstab# Created by anaconda on Wed May 3 08:41:37 2017## Accessible filesystems, by reference, are maintained under &apos;/dev/disk&apos;# See man pages fstab(5), findfs(8), mount(8) and/or blkid(8) for more info#/dev/mapper/vg0-root / ext4 defaults 1 1UUID=1b111728-c1d4-4814-bc8d-68376790c00e /boot ext4 defaults 1 2/dev/mapper/vg0-usr /usr ext4 defaults 1 2/dev/mapper/vg0-var /var ext4 defaults 1 2/dev/mapper/vg0-swap swap swap defaults 0 0tmpfs /dev/shm tmpfs defaults 0 0devpts /dev/pts devpts gid=5,mode=620 0 0sysfs /sys sysfs defaults 0 0proc /proc proc defaults 0 0UUID=9220e3b8-ac6f-4da5-883d-e7b20a8d1400 /home ext4 defaults 0 0 最后一行UUID是home挂载到的新分区的UUID。/dev/sdb1 9.生效mount -a 10.退出单用户模式init 5 11.卸载临时目录并删除123456789101112131415161718[root@localhost home]# umount /mnt/home[root@localhost home]# rmdir /mnt/home[root@localhost home]# [root@localhost home]# [root@localhost home]# [root@localhost home]# [root@localhost home]# lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINTsr0 11:0 1 1024M 0 rom sda 8:0 0 100G 0 disk ├─sda1 8:1 0 200M 0 part /boot└─sda2 8:2 0 60G 0 part ├─vg0-root (dm-0) 253:0 0 20G 0 lvm / ├─vg0-swap (dm-1) 253:1 0 2G 0 lvm [SWAP] ├─vg0-usr (dm-2) 253:2 0 10G 0 lvm /usr └─vg0-var (dm-3) 253:3 0 20G 0 lvm /varsdb 8:16 0 20G 0 disk └─sdb1 8:17 0 5G 0 part /home 使用lsblk命令查询分区信息后发现。/home目录已经迁移到了sdb1上。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[每天一个linux命令--which]]></title>
      <url>%2F2017%2F04%2F23%2Fevery-day-linux-command16-which%2F</url>
      <content type="text"><![CDATA[每天一个linux命令–which文章转载自博客园，作者peida。本文仅作为自用参考，请勿转载。 我们经常在linux要查找某个文件，但不知道放在哪里了，可以使用下面的一些命令来搜索： which 查看可执行文件的位置。 whereis 查看文件的位置。 locate 配合数据库查看文件位置。 find 实际搜寻硬盘查询文件名称。 which命令的作用是，在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。 1．命令格式： which 可执行文件名称 2．命令功能： which指令会在PATH变量指定的路径中，搜索某个系统命令的位置，并且返回第一个搜索结果。 3．命令参数： -n 指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。 -p 与-n参数相同，但此处的包括了文件的路径。 -w 指定输出时栏位的宽度。 -V 显示版本信息 4．使用实例： 实例1：查找文件、显示命令路径 命令： which lsmod 输出：123456789[root@localhost ~]# which pwd/bin/pwd[root@localhost ~]# which adduser/usr/sbin/adduser[root@localhost ~]# 说明： which 是根据使用者所配置的 PATH 变量内的目录去搜寻可运行档的！所以，不同的 PATH 配置内容所找到的命令当然不一样的！ 实例2：用 which 去找出 which 命令： which which 输出：1234567[root@localhost ~]# which whichalias which=&apos;alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde&apos; /usr/bin/which[root@localhost ~]# 说明： 竟然会有两个 which ，其中一个是 alias 这就是所谓的『命令别名』，意思是输入 which 会等于后面接的那串命令！ cd 这个常用的命令竟然找不到啊！为什么呢？这是因为 cd 是bash 内建的命令！ 但是 which 默认是找 PATH 内所规范的目录，所以当然一定找不到的！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[每天一个linux命令--tail]]></title>
      <url>%2F2017%2F04%2F22%2Fevery-day-linux-command15-tail%2F</url>
      <content type="text"><![CDATA[每天一个linux命令–tail文章转载自博客园，作者peida。本文仅作为自用参考，请勿转载。 tail 命令从指定点开始将文件写到标准输出.使用tail命令的-f选项可以方便的查阅正在改变的日志文件,tail -f filename会把filename里最尾部的内容显示在屏幕上,并且不但刷新,使你看到最新的文件内容. 1．命令格式; tail[必要参数][选择参数][文件] 2．命令功能： 用于显示指定文件末尾内容，不指定文件时，作为输入信息进行处理。常用查看日志文件。 3．命令参数： -f 循环读取 -q 不显示处理信息 -v 显示详细的处理信息 -c&lt;数目&gt; 显示的字节数 -n&lt;行数&gt; 显示行数 --pid=PID 与-f合用,表示在进程ID,PID死掉之后结束. -q, --quiet, --silent 从不输出给出文件名的首部 -s, --sleep-interval=S 与-f合用,表示在每次反复的间隔休眠S秒 4．使用实例： 实例1：显示文件末尾内容 命令： tail -n 5 log2014.log 输出：1234567891011[root@localhost test]# tail -n 5 log2014.log 2014-092014-102014-112014-12[root@localhost test]# 说明： 显示文件最后5行内容 实例2：循环查看文件内容 命令： tail -f test.log 输出：1234567891011121314151617181920212223242526272829[root@localhost ~]# ping 192.168.120.204 &gt; test.log &amp;[1] 11891[root@localhost ~]# tail -f test.log PING 192.168.120.204 (192.168.120.204) 56(84) bytes of data.64 bytes from 192.168.120.204: icmp_seq=1 ttl=64 time=0.038 ms64 bytes from 192.168.120.204: icmp_seq=2 ttl=64 time=0.036 ms64 bytes from 192.168.120.204: icmp_seq=3 ttl=64 time=0.033 ms64 bytes from 192.168.120.204: icmp_seq=4 ttl=64 time=0.027 ms64 bytes from 192.168.120.204: icmp_seq=5 ttl=64 time=0.032 ms64 bytes from 192.168.120.204: icmp_seq=6 ttl=64 time=0.026 ms64 bytes from 192.168.120.204: icmp_seq=7 ttl=64 time=0.030 ms64 bytes from 192.168.120.204: icmp_seq=8 ttl=64 time=0.029 ms64 bytes from 192.168.120.204: icmp_seq=9 ttl=64 time=0.044 ms64 bytes from 192.168.120.204: icmp_seq=10 ttl=64 time=0.033 ms64 bytes from 192.168.120.204: icmp_seq=11 ttl=64 time=0.027 ms[root@localhost ~]# 说明： ping 192.168.120.204 &gt; test.log 在后台ping远程主机。并输出文件到test.log；这种做法也使用于一个以上 的档案监视。用Ctrl＋c来终止。 实例3：从第5行开始显示文件 命令： tail -n +5 log2014.log 输出：123456789101112131415161718192021222324252627282930313233343536373839404142434445[root@localhost test]# cat log2014.log 2014-012014-022014-032014-042014-052014-062014-072014-082014-092014-102014-112014-12==============================[root@localhost test]# tail -n +5 log2014.log2014-052014-062014-072014-082014-092014-102014-112014-12]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[每天一个linux命令--head]]></title>
      <url>%2F2017%2F04%2F21%2Fevery-day-linux-command14-head%2F</url>
      <content type="text"><![CDATA[每天一个linux命令–head文章转载自博客园，作者peida。本文仅作为自用参考，请勿转载。 head 与 tail 就像它的名字一样的浅显易懂，它是用来显示开头或结尾某个数量的文字区块，head 用来显示档案的开头至标准输出中，而 tail 想当然尔就是看档案的结尾。 1．命令格式： head [参数]... [文件]... 2．命令功能： head 用来显示档案的开头至标准输出中，默认head命令打印其相应文件的开头10行。 3．命令参数： -q 隐藏文件名 -v 显示文件名 -c&lt;字节&gt; 显示字节数 -n&lt;行数&gt; 显示的行数 4．使用实例： 实例1：显示文件的前n行 命令： head -n 5 log2014.log 输出：123456789101112131415161718192021222324252627282930313233343536373839[root@localhost test]# cat log2014.log 2014-012014-022014-032014-042014-052014-062014-072014-082014-092014-102014-112014-12==============================[root@localhost test]# head -n 5 log2014.log 2014-012014-022014-032014-042014-05[root@localhost test]# 实例2：显示文件前n个字节 命令： head -c 20 log2014.log 输出：123456789[root@localhost test]# head -c 20 log2014.log2014-012014-022014[root@localhost test]# 实例3：文件的除了最后n个字节以外的内容 命令： head -c -32 log2014.log 输出：12345678910111213141516171819202122232425[root@localhost test]# head -c -32 log2014.log2014-012014-022014-032014-042014-052014-062014-072014-082014-092014-102014-112014-12[root@localhost test]# 实例4：输出文件除了最后n行的全部内容 命令： head -n -6 log2014.log 输出：123456789101112131415[root@localhost test]# head -n -6 log2014.log2014-012014-022014-032014-042014-052014-062014-07[root@localhost test]#]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[每天一个linux命令--less]]></title>
      <url>%2F2017%2F04%2F20%2Fevery-day-linux-command13-less%2F</url>
      <content type="text"><![CDATA[每天一个linux命令–less文章转载自博客园，作者peida。本文仅作为自用参考，请勿转载。 每天一个linux命令–less less 工具也是对文件或其它输出进行分页显示的工具，应该说是linux正统查看文件内容的工具，功能极其强大。less 的用法比起 more 更加的有弹性。在 more 的时候，我们并没有办法向前面翻， 只能往后面看，但若使用了 less 时，就可以使用 [pageup] [pagedown] 等按键的功能来往前往后翻看文件，更容易用来查看一个文件的内容！除此之外，在 less 里头可以拥有更多的搜索功能，不止可以向下搜，也可以向上搜。 1．命令格式： less [参数] 文件 2．命令功能： less与more类似，但使用less 可以随意浏览文件，而more仅能向前移动，却不能向后移动， 而且less在查看之前不会加载整个文件。 3．命令参数： -b &lt;缓冲区大小&gt; 设置缓冲区的大小 -e 当文件显示结束后，自动离开 -f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件 -g 只标志最后搜索的关键词 -i 忽略搜索时的大小写 -m 显示类似more命令的百分比 -N 显示每行的行号 -o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来 -Q 不使用警告音 -s 显示连续空行为一行 -S 行过长时间将超出部分舍弃 -x &lt;数字&gt; 将“tab”键显示为规定的数字空格 /字符串：向下搜索“字符串”的功能 ?字符串：向上搜索“字符串”的功能 n：重复前一个搜索（与 / 或 ? 有关） N：反向重复前一个搜索（与 / 或 ? 有关） b 向后翻一页 d 向后翻半页 h 显示帮助界面 Q 退出less 命令 u 向前滚动半页 y 向前滚动一行 空格键 滚动一行 回车键 滚动一页 [pagedown]： 向下翻动一页 [pageup]： 向上翻动一页]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[每天一个linux命令--more]]></title>
      <url>%2F2017%2F04%2F19%2Fevery-day-linux-command12-more%2F</url>
      <content type="text"><![CDATA[每天一个linux命令–more文章转载自博客园，作者peida。本文仅作为自用参考，请勿转载。 more命令，功能类似 cat ，cat命令是整个文件的内容从上到下显示在屏幕上。 more会以一页一页的显示方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能 。more命令从前向后读取文件，因此在启动时就加载整个文件。 1．命令格式： more [-dlfpcsu ] [-num ] [+/ pattern] [+ linenum] [file ... ] 2．命令功能： more命令和cat的功能一样都是查看文件里的内容，但有所不同的是more可以按页来查看文件的内容，还支持直接跳转行等功能。 3．命令参数： +n 从笫n行开始显示 -n 定义屏幕大小为n行 +/pattern 在每个档案显示前搜寻该字串（pattern），然后从该字串前两行之后开始显示 -c 从顶部清屏，然后显示 -d 提示“Press space to continue，’q’ to quit（按空格键继续，按q键退出）”，禁用响铃功能 -l 忽略Ctrl+l（换页）字符 -p 通过清除窗口而不是滚屏来对文件进行换页，与-c选项相似 -s 把连续的多个空行显示为一行 -u 把文件内容中的下画线去掉 4．常用操作命令： Enter 向下n行，需要定义。默认为1行 Ctrl+F 向下滚动一屏 空格键 向下滚动一屏 Ctrl+B 返回上一屏 = 输出当前行的行号 ：f 输出文件名和当前行的行号 V 调用vi编辑器 !命令 调用Shell，并执行命令 q 退出more 5．命令实例： 实例1：显示文件中从第3行起的内容 命令： more +3 log2012.log 输出：1234567891011121314151617181920212223242526272829303132333435[root@localhost test]# cat log2012.log 2012-012012-022012-032012-04-day12012-04-day22012-04-day3======[root@localhost test]# more +3 log2012.log 2012-032012-04-day12012-04-day22012-04-day3======[root@localhost test]#``` 实例2：从文件中查找第一个出现&quot;day3&quot;字符串的行，并从该处前两行开始显示输出 命令： more +/day3 log2012.log输出： [root@localhost test]# more +/day3 log2012.log …skipping 2012-04-day1 2012-04-day2 2012-04-day3 2012-05 2012-05-day1 ======[root@localhost test]#1234567实例3：设定每屏显示行数 命令： more -5 log2012.log输出： [root@localhost test]# more -5 log2012.log 2012-01 2012-02 2012-03 2012-04-day1 2012-04-day2123456789101112说明： 如下图所示，最下面显示了该屏展示的内容占文件总行数的比例，按 Ctrl+F 或者空格键 将会显示下一屏5条内容， 百分比也会跟着变化。实例4：列一个目录下的文件，由于内容太多，我们应该学会用more来分页显示。这得和管道 | 结合起来 命令： ls -l | more -5输出： [root@localhost test]# ls -l | more -5 总计 36 -rw-r–r– 1 root root 308 11-01 16:49 log2012.log -rw-r–r– 1 root root 33 10-28 16:54 log2013.log -rw-r–r– 1 root root 127 10-28 16:51 log2014.log lrwxrwxrwx 1 root root 7 10-28 15:18 log_link.log -&gt; log.log -rw-r–r– 1 root root 25 10-28 17:02 log.log -rw-r–r– 1 root root 37 10-28 17:07 log.txt drwxr-xr-x 6 root root 4096 10-27 01:58 scf drwxrwxrwx 2 root root 4096 10-28 14:47 test3 drwxrwxrwx 2 root root 4096 10-28 14:47 test4```说明： 每页显示5个文件信息，按 Ctrl+F 或者 空格键 将会显示下5条文件信息。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[每天一个linux命令--nl]]></title>
      <url>%2F2017%2F04%2F18%2Fevery-day-linux-command11-nl%2F</url>
      <content type="text"><![CDATA[每天一个linux命令–nl文章转载自博客园，作者peida。本文仅作为自用参考，请勿转载。 nl命令在linux系统中用来计算文件中行号。nl 可以将输出的文件内容自动的加上行号！其默认的结果与 cat -n 有点不太一样， nl 可以将行号做比较多的显示设计，包括位数与是否自动补齐 0 等等的功能。 1．命令格式：nl [选项]... [文件]... 2．命令参数：-b ：指定行号指定的方式，主要有两种： -b a ：表示不论是否为空行，也同样列出行号(类似 cat -n)； -b t ：如果有空行，空的那一行不要列出行号(默认值)； -n ：列出行号表示的方法，主要有三种： -n ln ：行号在萤幕的最左方显示； -n rn ：行号在自己栏位的最右方显示，且不加 0 ； -n rz ：行号在自己栏位的最右方显示，且加 0 ； -w ：行号栏位的占用的位数。 -p 在逻辑定界符处不重新开始计算。 3．命令功能：nl 命令读取 File 参数（缺省情况下标准输入），计算输入中的行号，将计算过的行号写入标准输出。 在输出中，nl 命令根据您在命令行中指定的标志来计算左边的行。输入文本必须写在逻辑页中。每个 逻辑页有头、主体和页脚节（可以有空节）。 除非使用 -p 标志，nl 命令在每个逻辑页开始的地方重新 设置行号。 可以单独为头、主体和页脚节设置行计算标志（例如，头和页脚行可以被计算然而文本行不能）。 4．使用实例：实例一：用 nl 列出 log2012.log 的内容 命令： nl log2012.log 输出：1234567891011[root@localhost test]# nl log2012.log 1 2012-01 2 2012-02 3 ======[root@localhost test]# 说明： 文件中的空白行，nl 不会加上行号 实例二：用 nl 列出 log2012.log 的内容，空本行也加上行号 命令： nl -b a log2012.log 输出：1234567891011[root@localhost test]# nl -b a log2012.log 1 2012-01 2 2012-02 3 4 5 ======[root@localhost test]# 实例3：让行号前面自动补上0,统一输出格式 命令： 输出：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455[root@localhost test]# nl -b a -n rz log2014.log 000001 2014-01000002 2014-02000003 2014-03000004 2014-04000005 2014-05000006 2014-06000007 2014-07000008 2014-08000009 2014-09000010 2014-10000011 2014-11000012 2014-12000013 =======[root@localhost test]# nl -b a -n rz -w 3 log2014.log 001 2014-01002 2014-02003 2014-03004 2014-04005 2014-05006 2014-06007 2014-07008 2014-08009 2014-09010 2014-10011 2014-11012 2014-12013 ======= 说明： nl -b a -n rz 命令行号默认为六位，要调整位数可以加上参数 -w 3 调整为3位。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[每天一个linux命令--cat]]></title>
      <url>%2F2017%2F04%2F17%2Fevery-day-linux-command10-cat%2F</url>
      <content type="text"><![CDATA[每天一个linux命令–cat文章转载自博客园，作者peida。本文仅作为自用参考，请勿转载。 cat命令的用途是连接文件或标准输入并打印。这个命令常用来显示文件内容，或者将几个文件连接起来显示，或者从标准输入读取内容并显示，它常与重定向符号配合使用。 1．命令格式：cat [选项] [文件]... 2．命令功能：cat主要有三大功能： 1.一次显示整个文件:cat filename 2.从键盘创建一个文件:cat &gt; filename 只能创建新文件,不能编辑已有文件. 3.将几个文件合并为一个文件:cat file1 file2 &gt; file 3．命令参数：-A, --show-all 等价于 -vET -b, --number-nonblank 对非空输出行编号 -e 等价于 -vE -E, --show-ends 在每行结束处显示 $ -n, --number 对输出的所有行编号,由1开始对所有输出的行数编号 -s, --squeeze-blank 有连续两行以上的空白行，就代换为一行的空白行 -t 与 -vT 等价 -T, --show-tabs 将跳格字符显示为 ^I -u (被忽略) -v, --show-nonprinting 使用 ^ 和 M- 引用，除了 LFD 和 TAB 之外 4．使用实例：实例一：把 log2012.log 的文件内容加上行号后输入 log2013.log 这个文件里 命令： cat -n log2012.log log2013.log 输出：12345678910111213141516171819202122232425262728293031323334353637[root@localhost test]# cat log2012.log 2012-012012-02======[root@localhost test]# cat log2013.log 2013-012013-022013-03======[root@localhost test]# cat -n log2012.log log2013.log 1 2012-01 2 2012-02 3 4 5 ====== 6 2013-01 7 2013-02 8 9 10 2013-03 11 ======[root@localhost test]# 实例二：把 log2012.log 和 log2013.log 的文件内容加上行号（空白行不加）之后将内容附加到 log.log 里。 命令： cat -b log2012.log log2013.log log.log 输出：123456789101112131415[root@localhost test]# cat -b log2012.log log2013.log log.log 1 2012-01 2 2012-02 3 ====== 4 2013-01 5 2013-02 6 2013-03 7 ======[root@localhost test]# 实例三：把 log2012.log 的文件内容加上行号后输入 log.log 这个文件里 命令： 输出：1234567891011121314151617[root@localhost test]# cat log.log [root@localhost test]# cat -n log2012.log &gt; log.log[root@localhost test]# cat -n log.log 1 2012-01 2 2012-02 3 4 5 ======[root@localhost test]# 实例四：使用here doc来生成文件 输出：123456789101112131415161718192021222324252627[root@localhost test]# cat &gt;log.txt &lt;&lt;EOF&gt; Hello&gt; World&gt; Linux&gt; PWD=$(pwd)&gt; EOF[root@localhost test]# ls -l log.txt -rw-r--r-- 1 root root 37 10-28 17:07 log.txt[root@localhost test]# cat log.txt HelloWorldLinuxPWD=/opt/soft/test[root@localhost test]# 说明： 注意粗体部分，here doc可以进行字符串替换。 备注： tac (反向列示) 命令： tac log.txt 输出：123456789[root@localhost test]# tac log.txt PWD=/opt/soft/testLinuxWorldHello 说明： tac 是将 cat 反写过来，所以他的功能就跟 cat 相反， cat是由第一行到最后一行连续显示在萤幕上， 而 tac 则是由最后一行到第一行反向在萤幕上显示出来！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[每天一个linux命令--touch]]></title>
      <url>%2F2017%2F04%2F16%2Fevery-day-linux-command9-touch%2F</url>
      <content type="text"><![CDATA[每天一个linux命令–touch文章转载自博客园，作者peida。本文仅作为自用参考，请勿转载。 Linux的touch命令不常用，一般在使用make的时候可能会用到，用来修改文件时间戳，或者新建一个不存在的文件。 1．命令格式：touch [选项]... 文件... 2．命令参数：-a 或--time=atime或--time=access或--time=use 只更改存取时间。 -c 或--no-create 不建立任何文档。 -d 使用指定的日期时间，而非现在的时间。 -f 此参数将忽略不予处理，仅负责解决BSD版本touch指令的兼容性问题。 -m 或--time=mtime或--time=modify 只更改变动时间。 -r 把指定文档或目录的日期时间，统统设成和参考文档或目录的日期时间相同。 -t 使用指定的日期时间，而非现在的时间。 3．命令功能：touch命令参数可更改文档或目录的日期时间，包括存取时间和更改时间。 4．使用范例：实例一：创建不存在的文件 命令： touch log2012.log log2013.log 输出：1234567891011121314151617[root@localhost test]# touch log2012.log log2013.log[root@localhost test]# ll-rw-r--r-- 1 root root 0 10-28 16:01 log2012.log-rw-r--r-- 1 root root 0 10-28 16:01 log2013.log如果log2014.log不存在，则不创建文件[root@localhost test]# touch -c log2014.log[root@localhost test]# ll-rw-r--r-- 1 root root 0 10-28 16:01 log2012.log-rw-r--r-- 1 root root 0 10-28 16:01 log2013.log 实例二：更新log.log的时间和log2012.log时间戳相同 命令： touch -r log.log log2012.log 输出：1234567891011121314151617[root@localhost test]# ll-rw-r--r-- 1 root root 0 10-28 16:01 log2012.log-rw-r--r-- 1 root root 0 10-28 16:01 log2013.log-rw-r--r-- 1 root root 0 10-28 14:48 log.log[root@localhost test]# touch -r log.log log2012.log [root@localhost test]# ll-rw-r--r-- 1 root root 0 10-28 14:48 log2012.log-rw-r--r-- 1 root root 0 10-28 16:01 log2013.log-rw-r--r-- 1 root root 0 10-28 14:48 log.log 实例三：设定文件的时间戳 命令： touch -t 201211142234.50 log.log 输出：1234567891011121314151617[root@localhost test]# ll-rw-r--r-- 1 root root 0 10-28 14:48 log2012.log-rw-r--r-- 1 root root 0 10-28 16:01 log2013.log-rw-r--r-- 1 root root 0 10-28 14:48 log.log[root@localhost test]# touch -t 201211142234.50 log.log[root@localhost test]# ll-rw-r--r-- 1 root root 0 10-28 14:48 log2012.log-rw-r--r-- 1 root root 0 10-28 16:01 log2013.log-rw-r--r-- 1 root root 0 2012-11-14 log.log 说明： -t time 使用指定的时间值 time 作为指定文件相应时间戳记的新值．此处的 time规定为如下形式的十进制数: [[CC]YY]MMDDhhmm[.SS] 这里，CC为年数中的前两位，即”世纪数”；YY为年数的后两位，即某世纪中的年数．如果不给出CC的值，则touch 将把年数CCYY限定在1969--2068之内．MM为月数，DD为天将把年数CCYY限定在1969--2068之内．MM为月数，DD 为天数hh 为小时数(几点)，mm为分钟数，SS为秒数。此处秒的设定范围是0--61，这样可以处理闰秒．这些数字组 成的时间是环境变量TZ指定的时区中的一个时间．由于系统的限制，早于1970年1月1日的时间是错误的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[每天一个linux命令--cp]]></title>
      <url>%2F2017%2F04%2F15%2Fevery-day-linux-command8-cp%2F</url>
      <content type="text"><![CDATA[每天一个linux命令–cp文章转载自博客园，作者peida。本文仅作为自用参考，请勿转载。 cp命令用来复制文件或者目录，是Linux系统中最常用的命令之一。一般情况下，shell会设置一个别名，在命令行下复制文件时，如果目标文件已经存在，就会询问是否覆盖，不管你是否使用-i参数。但是如果是在shell脚本中执行cp时，没有-i参数时不会询问是否覆盖。这说明命令行和shell脚本的执行方式有些不同。 1．命令格式：cp [选项]... [-T] 源 目的 或：cp [选项]... 源... 目录 或：cp [选项]... -t 目录 源... 2．命令功能：将源文件复制至目标文件，或将多个源文件复制至目标目录。 3．命令参数：-a, --archive 等于-dR --preserve=all --backup[=CONTROL 为每个已存在的目标文件创建备份 -b 类似--backup 但不接受参数 --copy-contents 在递归处理是复制特殊文件内容 -d 等于--no-dereference --preserve=links -f, --force 如果目标文件无法打开则将其移除并重试(当 -n 选项存在时则不需再选此项) -i, --interactive 覆盖前询问(使前面的 -n 选项失效) -H 跟随源文件中的命令行符号链接 -l, --link 链接文件而不复制 -L, --dereference 总是跟随符号链接 -n, --no-clobber 不要覆盖已存在的文件(使前面的 -i 选项失效) -P, --no-dereference 不跟随源文件中的符号链接 -p 等于--preserve=模式,所有权,时间戳 --preserve[=属性列表 保持指定的属性(默认：模式,所有权,时间戳)，如果可能保持附加属性： 环境、链接、xattr 等 -R, -r, --recursive 复制目录及目录内的所有项目 4．命令实例：实例一：复制单个文件到目标目录，文件在目标文件中不存在 命令： cp log.log test5 输出：1234567891011121314151617181920212223[root@localhost test]# cp log.log test5[root@localhost test]# ll-rw-r--r-- 1 root root 0 10-28 14:48 log.logdrwxr-xr-x 6 root root 4096 10-27 01:58 scfdrwxrwxrwx 2 root root 4096 10-28 14:47 test3drwxr-xr-x 2 root root 4096 10-28 14:53 test5[root@localhost test]# cd test5[root@localhost test5]# ll-rw-r--r-- 1 root root 0 10-28 14:46 log5-1.log-rw-r--r-- 1 root root 0 10-28 14:46 log5-2.log-rw-r--r-- 1 root root 0 10-28 14:46 log5-3.log-rw-r--r-- 1 root root 0 10-28 14:53 log.log 说明： 在没有带-a参数时，两个文件的时间是不一样的。在带了-a参数时，两个文件的时间是一致的。 实例二：目标文件存在时，会询问是否覆盖 命令： cp log.log test5 输出：12345678910111213141516171819[root@localhost test]# cp log.log test5cp：是否覆盖“test5/log.log”? n[root@localhost test]# cp -a log.log test5cp：是否覆盖“test5/log.log”? y[root@localhost test]# cd test5/[root@localhost test5]# ll-rw-r--r-- 1 root root 0 10-28 14:46 log5-1.log-rw-r--r-- 1 root root 0 10-28 14:46 log5-2.log-rw-r--r-- 1 root root 0 10-28 14:46 log5-3.log-rw-r--r-- 1 root root 0 10-28 14:48 log.log 说明： 目标文件存在时，会询问是否覆盖。这是因为cp是cp -i 的别名。目标文件存在时，即使加了-f标志，也还会询问是否覆盖。 实例三：复制整个目录 命令： 输出：123456789101112131415161718192021222324252627282930313233343536373839404142434445目标目录存在时：[root@localhost test]# cp -a test3 test5 [root@localhost test]# ll-rw-r--r-- 1 root root 0 10-28 14:48 log.logdrwxr-xr-x 6 root root 4096 10-27 01:58 scfdrwxrwxrwx 2 root root 4096 10-28 14:47 test3drwxr-xr-x 3 root root 4096 10-28 15:11 test5[root@localhost test]# cd test5/[root@localhost test5]# ll-rw-r--r-- 1 root root 0 10-28 14:46 log5-1.log-rw-r--r-- 1 root root 0 10-28 14:46 log5-2.log-rw-r--r-- 1 root root 0 10-28 14:46 log5-3.log-rw-r--r-- 1 root root 0 10-28 14:48 log.logdrwxrwxrwx 2 root root 4096 10-28 14:47 test3目标目录不存在是：[root@localhost test]# cp -a test3 test4[root@localhost test]# ll-rw-r--r-- 1 root root 0 10-28 14:48 log.logdrwxr-xr-x 6 root root 4096 10-27 01:58 scfdrwxrwxrwx 2 root root 4096 10-28 14:47 test3drwxrwxrwx 2 root root 4096 10-28 14:47 test4drwxr-xr-x 3 root root 4096 10-28 15:11 test5[root@localhost test]# 说明： 注意目标目录存在与否结果是不一样的。目标目录存在时，整个源目录被复制到目标目录里面。 实例四：复制的 log.log 建立一个连结档 log_link.log 命令： cp -s log.log log_link.log 输出：123456789101112131415[root@localhost test]# cp -s log.log log_link.log[root@localhost test]# lllrwxrwxrwx 1 root root 7 10-28 15:18 log_link.log -&gt; log.log-rw-r--r-- 1 root root 0 10-28 14:48 log.logdrwxr-xr-x 6 root root 4096 10-27 01:58 scfdrwxrwxrwx 2 root root 4096 10-28 14:47 test3drwxrwxrwx 2 root root 4096 10-28 14:47 test4drwxr-xr-x 3 root root 4096 10-28 15:11 test5 说明： 那个 log_link.log 是由 -s 的参数造成的，建立的是一个『快捷方式』， 所以您会看到在文件的最右边，会显示这个文件是『连结』到哪里去的！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux运维脚本编写规范]]></title>
      <url>%2F2017%2F04%2F14%2Fshell-guifan%2F</url>
      <content type="text"><![CDATA[Linux运维脚本编写规范1.脚本名以.sh结尾，名称尽量见名知意，比如，ClearLog.sh、 Clear_Log.sh、clearlog.sh、SerRestart.sh、Ser_Restart.sh; 2.尽量使用UTF-8编码，注释及输出尽量使用英文。 3.一般情况下都赋予执行权限，但一些关于变量的配置文件不用加执行权限。 4.脚本执行的时候可以使用bash执行，或者使用bash -x执行，可以直观的显示具体的执行过程。 5.脚本首行使用#!/bin/bash,没有空格，不带任何选项。 6.第二行为空格，或者是添加一行注释。 7.第三行开始注释内容：文件名、功能描述、作者、最后修改日期、版本号、以及一些说明、还加上邮箱等联系方式、如果可以，需要加上版权声明。1234567891011脚本示例 #!/bin/bash #调用语言 # # Filename: test.sh # Description: this is Description # Author： leessangz # Email: leessangz@gmail.com # Revision: 0.1 # Date: 2017-07-01 # Note: test # 8.注释内容之后空一行开始定义shell脚本中的变量。 9.脚本内的变量定义，尽量使用大写，或者每个单词的首字母大写的驼峰原则，或者使用下划线连接的方式，变量名要见名知意，避免a，b，c，类似的定义，变量定义前后不要用空格。1234脚本示例 YUM_CMD=&quot;/usr/bin/yum&quot; YUMCMD=&quot;/usr/bin/yum&quot; Yum_Cmd=&quot;/usr/bin/yum&quot; 如果是整形，需要使用declare -i来声明。 如果是数组，则需要使用declare -a来声明。 如果是只读变量，则需要使用declare -r来声明。 变量值尽量使用双引号引起来，如果要使用强引用，如变量值中包含$符号，则使用&apos;&apos;单引号引起来。 ShiLi=&apos;shili$shili&apos; 如果要将命令的执行结果赋值给变量，则使用反引号，或者$() ScriptDir=$(cd $(dirname $0) &amp;&amp; pwd) ScriptDir=`pwd` 变量的引用使用以下方法： ${ShiLi} $ShiLi 推荐使用第一种，如：tar zcf ${ShiLi}.tar.gz /apps/data/ 11.单引号和双引号混合使用的场景： echo ‘Welcome to “my school”‘ 12.在某些特殊的环境下，shell脚本里引用的命令，有可能是自己定义的bin路径，在执行的时候会报出command not found， 解决的方式是在执行的时候命令跟全路径，或者在脚本的开始，先设置一下PATH变量 如： export PATH=”/usr/local/bin:/usr/bin:/bin:/usr/local/sbin:/usr/sbin:/sbin:/apps/bin/“ 13.建议在脚本执行的开始重读下/etc/profile 或者是自己定义的关于环境变量的配置文件，推荐使用source， 如： source /etc/profile source /opt/sh/appenv.sh 14.使用here document； 如果脚本在执行的时候需要大段输出提示信息，可以使用以下方式： cat &lt;&lt; EOF This scripts used for XXX Usage:$0 [option] Pls be careful. Enjoy Yourself. EOF 如果只是单行提示信息，可以使用echo的方式添加颜色： echo &quot;Welcome to use my script&quot; 15.如果需要在脚本里生成配置文件的模板，也可以使用here document的方式，示例如下：12345678910111213141516示例脚本： cat&gt;&gt;/etc/rsyncd.conf&lt;&lt;EOF log file = /usr/local/logs/rsyncd.log transfer logging = yes log format = %t %a %m %f %b syslog facility = local3 timeout = 300 [data1] path=/home/username list=yes ignore errors auth users = data1user secrets file=/etc/rsyncd/rsyncd.secrets comment = some description about this moudle exclude = test1/ test2/ EOF 16.如果需要创建历史文件，可以使用以下方法： mktemp -d /tmp/file$$ 17.条件测试时尽量使用[[]],而不用[]或者test，因为[[]]功能会更强大。 [[ -d /tmp/logs ]] 不在使用[ “x$NAME” == “x” ]这种方式； 18.算数运算使用(())或者是中括号，但是记得括号里面的变量不要在加$ ((12+i)) 而非((12+$i)) 19.使用高级变量的方法，比如使用 ${ShiLi:?”Error Message”}确保关键变量已经定义 ${ShiLi:=”S1”} 或者设置默认值 否则： rm -rf ${ShiLi}/* 后果不堪设想 20.可以使用&amp;&amp; ||来替代简单的if-then-else-fi语句。 21.尽量给每条语句或者代码段的执行给一个执行结果状态，如果某条命令执行失败，则exit N.尽可能使用$?来检查前面一条命令的执行状态。 22.流程控制语句尽量使用一下方式：1234567891011for I in &#123;1..10&#125;;do ...donewhile true;do ...doneif [];then ...fi 23.如果命令过长，可以分成多行来写，比如：12345678./configure \--prefix=/usr \--sbin-path=/usr/sbin/nginx \--conf-path=/etc/nginx/nginx.conf \--error-log-path=/var/log/nginx/error.log \--http-log-path=/var/log/nginx/access.log \--pid-path=/var/run/nginx/nginx.pid \--lock-path=/var/lock/nginx.lock \ 24.shell脚本并不要求强制缩进，但是要养成缩进的好习惯，可以使用两个空格，建议使用tab键。如： if [];then …24. fi 25.尽可能多的注释信息。 26.想要获取当前脚本所在目录，可以使用 ScriptDir=$(cd $(dirname $0) &amp;&amp; pwd) 27.尽可能使用函数的功能，将不同的功能定义为函数，直接引用函数； 28.如果自定义环境变量，可以专门写到一个文件中，避免在/etc/profile中添加； 29.禁止使用SUID和SGID以及ACL用户访问控制列表的功能，如果需要较高权限，可以使用sudo。 30.关键的操作须有日志输出，专门记录操作的成功或者失败以及执行的时间点。 31.脚本内可能包含敏感信息，比如服务器密码或者数据库密码，如果公开之前请先确认敏感信息是否已经被删除。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[每天一个linux命令--mv]]></title>
      <url>%2F2017%2F04%2F14%2Fevery-day-linux-command7-mv%2F</url>
      <content type="text"><![CDATA[每天一个linux命令–mv文章转载自博客园，作者peida。本文仅作为自用参考，请勿转载。 mv命令是move的缩写，可以用来移动文件或者将文件改名（move (rename) files），是Linux系统下常用的命令，经常用来备份文件或者目录。 1．命令格式：mv [选项] 源文件或目录 目标文件或目录 2．命令功能：视mv命令中第二个参数类型的不同（是目标文件还是目标目录），mv命令将文件重命名或 将其移至一个新的目录中。当第二个参数类型是文件时，mv命令完成文件重命名，此时， 源文件只能有一个（也可以是源目录名），它将所给的源文件或目录重命名为给定的目标 文件名。当第二个参数是已存在的目录名称时，源文件或目录参数可以有多个，mv命令将 各参数指定的源文件均移至目标目录中。在跨文件系统移动文件时，mv先拷贝，再将原有 文件删除，而链至该文件的链接也将丢失。 3．命令参数：-b ：若需覆盖文件，则覆盖前先行备份。 -f ：force 强制的意思，如果目标文件已经存在，不会询问而直接覆盖； -i ：若目标文件 (destination) 已经存在时，就会询问是否覆盖！ -u ：若目标文件已经存在，且 source 比较新，才会更新(update) -t ： --target-directory=DIRECTORY move all SOURCE arguments into DIRECTORY， 即指定mv的目标目录，该选项适用于移动多个源文件到一个目录的情k况，此时目标目录在前，源文件在后。 4．命令实例：实例一：文件改名 命令： mv test.log test1.txt 输出：12345678910111213141516171819202122232425[root@localhost test]# ll总计 20drwxr-xr-x 6 root root 4096 10-27 01:58 scfdrwxrwxrwx 2 root root 4096 10-25 17:46 test3drwxr-xr-x 2 root root 4096 10-25 17:56 test4drwxr-xr-x 3 root root 4096 10-25 17:56 test5-rw-r--r-- 1 root root 16 10-28 06:04 test.log[root@localhost test]# mv test.log test1.txt[root@localhost test]# ll总计 20drwxr-xr-x 6 root root 4096 10-27 01:58 scf-rw-r--r-- 1 root root 16 10-28 06:04 test1.txtdrwxrwxrwx 2 root root 4096 10-25 17:46 test3drwxr-xr-x 2 root root 4096 10-25 17:56 test4drwxr-xr-x 3 root root 4096 10-25 17:56 test5 说明： 将文件test.log重命名为test1.txt 实例二：移动文件 命令： mv test1.txt test3 输出：123456789101112131415161718192021222324252627282930313233[root@localhost test]# ll总计 20drwxr-xr-x 6 root root 4096 10-27 01:58 scf-rw-r--r-- 1 root root 29 10-28 06:05 test1.txtdrwxrwxrwx 2 root root 4096 10-25 17:46 test3drwxr-xr-x 2 root root 4096 10-25 17:56 test4drwxr-xr-x 3 root root 4096 10-25 17:56 test5[root@localhost test]# mv test1.txt test3[root@localhost test]# ll总计 16drwxr-xr-x 6 root root 4096 10-27 01:58 scfdrwxrwxrwx 2 root root 4096 10-28 06:09 test3drwxr-xr-x 2 root root 4096 10-25 17:56 test4drwxr-xr-x 3 root root 4096 10-25 17:56 test5[root@localhost test]# cd test3[root@localhost test3]# ll总计 4-rw-r--r-- 1 root root 29 10-28 06:05 test1.txt[root@localhost test3]# 说明： 将test1.txt文件移到目录test3中 实例三：将文件log1.txt,log2.txt,log3.txt移动到目录test3中。 命令： mv log1.txt log2.txt log3.txt test3 mv -t /opt/soft/test/test4/ log1.txt log2.txt log3.txt 输出：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465[root@localhost test]# ll总计 28-rw-r--r-- 1 root root 8 10-28 06:15 log1.txt-rw-r--r-- 1 root root 12 10-28 06:15 log2.txt-rw-r--r-- 1 root root 13 10-28 06:16 log3.txtdrwxrwxrwx 2 root root 4096 10-28 06:09 test3[root@localhost test]# mv log1.txt log2.txt log3.txt test3[root@localhost test]# ll总计 16drwxrwxrwx 2 root root 4096 10-28 06:18 test3[root@localhost test]# cd test3/[root@localhost test3]# ll总计 16-rw-r--r-- 1 root root 8 10-28 06:15 log1.txt-rw-r--r-- 1 root root 12 10-28 06:15 log2.txt-rw-r--r-- 1 root root 13 10-28 06:16 log3.txt-rw-r--r-- 1 root root 29 10-28 06:05 test1.txt[root@localhost test3]#[root@localhost test3]# ll总计 20-rw-r--r-- 1 root root 8 10-28 06:15 log1.txt-rw-r--r-- 1 root root 12 10-28 06:15 log2.txt-rw-r--r-- 1 root root 13 10-28 06:16 log3.txtdrwxr-xr-x 2 root root 4096 10-28 06:21 logs-rw-r--r-- 1 root root 29 10-28 06:05 test1.txt[root@localhost test3]# mv -t /opt/soft/test/test4/ log1.txt log2.txt log3.txt [root@localhost test3]# cd ..[root@localhost test]# cd test4/[root@localhost test4]# ll总计 12-rw-r--r-- 1 root root 8 10-28 06:15 log1.txt-rw-r--r-- 1 root root 12 10-28 06:15 log2.txt-rw-r--r-- 1 root root 13 10-28 06:16 log3.txt[root@localhost test4]# 说明： mv log1.txt log2.txt log3.txt test3 命令将log1.txt ，log2.txt， log3.txt 三个文件移到 test3目录中去，mv -t /opt/soft/test/test4/ log1.txt log2.txt log3.txt 命令又将三个文件移动到test4目录中去 实例四：将文件file1改名为file2，如果file2已经存在，则询问是否覆盖 命令： mv -i log1.txt log2.txt 输出：123456789101112131415161718192021222324252627[root@localhost test4]# ll总计 12-rw-r--r-- 1 root root 8 10-28 06:15 log1.txt-rw-r--r-- 1 root root 12 10-28 06:15 log2.txt-rw-r--r-- 1 root root 13 10-28 06:16 log3.txt[root@localhost test4]# cat log1.txt odfdfs[root@localhost test4]# cat log2.txt ererwerwer[root@localhost test4]# mv -i log1.txt log2.txt mv：是否覆盖“log2.txt”? y[root@localhost test4]# cat log2.txt odfdfs[root@localhost test4]# 实例五：将文件file1改名为file2，即使file2存在，也是直接覆盖掉。 命令： mv -f log3.txt log2.txt 输出：123456789101112131415161718192021222324252627282930313233343536373839404142434445[root@localhost test4]# ll总计 8-rw-r--r-- 1 root root 8 10-28 06:15 log2.txt-rw-r--r-- 1 root root 13 10-28 06:16 log3.txt[root@localhost test4]# cat log2.txt odfdfs[root@localhost test4]# cat log3cat: log3: 没有那个文件或目录[root@localhost test4]# ll总计 8-rw-r--r-- 1 root root 8 10-28 06:15 log2.txt-rw-r--r-- 1 root root 13 10-28 06:16 log3.txt[root@localhost test4]# cat log2.txt odfdfs[root@localhost test4]# cat log3.txt dfosdfsdfdss[root@localhost test4]# mv -f log3.txt log2.txt [root@localhost test4]# cat log2.txt dfosdfsdfdss[root@localhost test4]# ll总计 4-rw-r--r-- 1 root root 13 10-28 06:16 log2.txt[root@localhost test4]# 说明： log3.txt的内容直接覆盖了log2.txt内容，-f 这是个危险的选项，使用的时候一定要保持头脑清晰，一般情况下最好不用加上它。 实例六：目录的移动 命令： mv dir1 dir2 输出：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051[root@localhost test4]# ll-rw-r--r-- 1 root root 13 10-28 06:16 log2.txt[root@localhost test4]# ll-rw-r--r-- 1 root root 13 10-28 06:16 log2.txt[root@localhost test4]# cd ..[root@localhost test]# lldrwxr-xr-x 6 root root 4096 10-27 01:58 scfdrwxrwxrwx 3 root root 4096 10-28 06:24 test3drwxr-xr-x 2 root root 4096 10-28 06:48 test4drwxr-xr-x 3 root root 4096 10-25 17:56 test5[root@localhost test]# cd test3[root@localhost test3]# lldrwxr-xr-x 2 root root 4096 10-28 06:21 logs-rw-r--r-- 1 root root 29 10-28 06:05 test1.txt[root@localhost test3]# cd ..[root@localhost test]# mv test4 test3[root@localhost test]# lldrwxr-xr-x 6 root root 4096 10-27 01:58 scfdrwxrwxrwx 4 root root 4096 10-28 06:54 test3drwxr-xr-x 3 root root 4096 10-25 17:56 test5[root@localhost test]# cd test3/[root@localhost test3]# lldrwxr-xr-x 2 root root 4096 10-28 06:21 logs-rw-r--r-- 1 root root 29 10-28 06:05 test1.txtdrwxr-xr-x 2 root root 4096 10-28 06:48 test4[root@localhost test3]# 说明： 如果目录dir2不存在，将目录dir1改名为dir2；否则，将dir1移动到dir2中。 实例7：移动当前文件夹下的所有文件到上一级目录 命令： mv * ../ 输出：1234567891011121314151617181920212223[root@localhost test4]# ll-rw-r--r-- 1 root root 25 10-28 07:02 log1.txt-rw-r--r-- 1 root root 13 10-28 06:16 log2.txt[root@localhost test4]# mv * ../[root@localhost test4]# ll[root@localhost test4]# cd ..[root@localhost test3]# ll-rw-r--r-- 1 root root 25 10-28 07:02 log1.txt-rw-r--r-- 1 root root 13 10-28 06:16 log2.txtdrwxr-xr-x 2 root root 4096 10-28 06:21 logs-rw-r--r-- 1 root root 29 10-28 06:05 test1.txtdrwxr-xr-x 2 root root 4096 10-28 07:02 test4 实例八：把当前目录的一个子目录里的文件移动到另一个子目录里 命令： mv test3/*.txt test5 输出：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849[root@localhost test]# lldrwxr-xr-x 6 root root 4096 10-27 01:58 scfdrwxrwxrwx 4 root root 4096 10-28 07:02 test3drwxr-xr-x 3 root root 4096 10-25 17:56 test5[root@localhost test]# cd test3[root@localhost test3]# ll-rw-r--r-- 1 root root 25 10-28 07:02 log1.txt-rw-r--r-- 1 root root 13 10-28 06:16 log2.txtdrwxr-xr-x 2 root root 4096 10-28 06:21 logs-rw-r--r-- 1 root root 29 10-28 06:05 test1.txtdrwxr-xr-x 2 root root 4096 10-28 07:02 test4[root@localhost test3]# cd ..[root@localhost test]# mv test3/*.txt test5[root@localhost test]# cd test5[root@localhost test5]# ll-rw-r--r-- 1 root root 25 10-28 07:02 log1.txt-rw-r--r-- 1 root root 13 10-28 06:16 log2.txt-rw-r--r-- 1 root root 29 10-28 06:05 test1.txtdrwxr-xr-x 2 root root 4096 10-25 17:56 test5-1[root@localhost test5]# cd ..[root@localhost test]# cd test3/[root@localhost test3]# lldrwxr-xr-x 2 root root 4096 10-28 06:21 logsdrwxr-xr-x 2 root root 4096 10-28 07:02 test4[root@localhost test3]# 实例九：文件被覆盖前做简单备份，前面加参数-b 命令： mv log1.txt -b log2.txt 输出：12345678910111213141516171819202122232425[root@localhost test5]# ll-rw-r--r-- 1 root root 25 10-28 07:02 log1.txt-rw-r--r-- 1 root root 13 10-28 06:16 log2.txt-rw-r--r-- 1 root root 29 10-28 06:05 test1.txtdrwxr-xr-x 2 root root 4096 10-25 17:56 test5-1[root@localhost test5]# mv log1.txt -b log2.txtmv：是否覆盖“log2.txt”? y[root@localhost test5]# ll-rw-r--r-- 1 root root 25 10-28 07:02 log2.txt-rw-r--r-- 1 root root 13 10-28 06:16 log2.txt~-rw-r--r-- 1 root root 29 10-28 06:05 test1.txtdrwxr-xr-x 2 root root 4096 10-25 17:56 test5-1[root@localhost test5]# 说明： -b 不接受参数，mv会去读取环境变量VERSION_CONTROL来作为备份策略。 --backup该选项指定如果目标文件存在时的动作，共有四种备份策略： 1.CONTROL=none或off : 不备份。 2.CONTROL=numbered或t：数字编号的备份 3.CONTROL=existing或nil：如果存在以数字编号的备份，则继续编号备份m+1...n： 执行mv操作前已存在以数字编号的文件log2.txt.~1~，那么再次执行将产生log2.txt~2~， 以次类推。如果之前没有以数字编号的文件，则使用下面讲到的简单备份。 4.CONTROL=simple或never：使用简单备份：在被覆盖前进行了简单备份，简单备份只能 有一份，再次被覆盖时，简单备份也会被覆盖。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[每天一个linux命令--rmdir]]></title>
      <url>%2F2017%2F04%2F13%2Fevery-day-linux-command6-rmdir%2F</url>
      <content type="text"><![CDATA[每天一个linux命令–rmdir文章转载自博客园，作者peida。本文仅作为自用参考，请勿转载。 今天学习一下linux中命令： rmdir命令。rmdir是常用的命令，该命令的功能是删除空目录，一个目录被删除之前必须是空的。（注意，rm - r dir命令可代替rmdir，但是有很大危险性。）删除某目录时也必须具有对父目录的写权限。 1．命令格式：rmdir [选项]... 目录... 2．命令功能：该命令从一个目录中删除一个或多个子目录项，删除某目录时也必须具有对父目录的写权限。 3．命令参数：-p 递归删除目录dirname，当子目录删除后其父目录为空时，也一同被删除。 如果整个路径被删除或者由于某种原因保留部分路径，则系统在标准输出上显示相应的信息。 -v, --verbose 显示指令执行过程 4．命令实例：实例一：rmdir 不能删除非空目录 命令： rmdir doc 输出：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667[root@localhost scf]# tree.|-- bin|-- doc| |-- info| `-- product|-- lib|-- logs| |-- info| `-- product`-- service `-- deploy |-- info `-- product 12 directories, 0 files[root@localhost scf]# rmdir docrmdir: doc: 目录非空[root@localhost scf]# rmdir doc/info[root@localhost scf]# rmdir doc/product[root@localhost scf]# tree.|-- bin|-- doc|-- lib|-- logs| |-- info| `-- product`-- service `-- deploy |-- info `-- product 10 directories, 0 files 说明： rmdir 目录名 命令不能直接删除非空目录 实例2：rmdir -p 当子目录被删除后使它也成为空目录的话，则顺便一并删除 命令： rmdir -p logs 输出：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879[root@localhost scf]# tree.|-- bin|-- doc|-- lib|-- logs| `-- product`-- service `-- deploy |-- info `-- product 10 directories, 0 files[root@localhost scf]# rmdir -p logsrmdir: logs: 目录非空[root@localhost scf]# tree.|-- bin|-- doc|-- lib|-- logs| `-- product`-- service `-- deploy |-- info `-- product 9 directories, 0 files[root@localhost scf]# rmdir -p logs/product[root@localhost scf]# tree.|-- bin|-- doc|-- lib`-- service`-- deploy |-- info `-- product 7 directories, 0 files]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[每天一个linux命令--rm]]></title>
      <url>%2F2017%2F04%2F12%2Fevery-day-linux-command5-rm%2F</url>
      <content type="text"><![CDATA[每天一个linux命令–rm文章转载自博客园，作者peida。本文仅作为自用参考，请勿转载。 昨天学习了创建文件和目录的命令mkdir ，今天学习一下linux中删除文件和目录的命令： rm命令。rm是常用的命令，该命令的功能为删除一个目录中的一个或多个文件或目录，它也可以将某个目录及其下的所有文件及子目录均删除。对于链接文件，只是删除了链接，原有文件均保持不变。 rm是一个危险的命令，使用的时候要特别当心，尤其对于新手，否则整个系统就会毁在这个命令（比如在/（根目录）下执行rm * -rf）。所以，我们在执行rm之前最好先确认一下在哪个目录，到底要删除什么东西，操作时保持高度清醒的头脑。 1．命令格式：rm [选项] 文件… 2．命令功能：删除一个目录中的一个或多个文件或目录，如果没有使用- r选项，则rm不会删除目录。 如果使用 rm 来删除文件，通常仍可以将该文件恢复原状。 3．命令参数：-f, --force 忽略不存在的文件，从不给出提示。 -i, --interactive 进行交互式删除 -r, -R, --recursive 指示rm将参数中列出的全部目录和子目录均递归地删除。 -v, --verbose 详细显示进行的步骤 --help 显示此帮助信息并退出 --version 输出版本信息并退出 4．命令实例：实例一：删除文件file，系统会先询问是否删除。 命令： rm 文件名 输出：12345678910111213[root@localhost test1]# ll总计 4-rw-r--r-- 1 root root 56 10-26 14:31 log.logroot@localhost test1]# rm log.log rm：是否删除 一般文件 “log.log”? yroot@localhost test1]# ll总计 0[root@localhost test1]# 说明： 输入rm log.log命令后，系统会询问是否删除，输入y后就会删除文件，不想删除则数据n。 实例二：强行删除file，系统不再提示。 命令： rm -f log1.log 输出：1234567891011[root@localhost test1]# ll总计 4-rw-r--r-- 1 root root 23 10-26 14:40 log1.log[root@localhost test1]# rm -f log1.log [root@localhost test1]# ll总计 0[root@localhost test1]# 实例三：删除任何.log文件；删除前逐一询问确认 命令： rm -i *.log 输出：1234567891011121314151617[root@localhost test1]# ll总计 8-rw-r--r-- 1 root root 11 10-26 14:45 log1.log-rw-r--r-- 1 root root 24 10-26 14:45 log2.log[root@localhost test1]# rm -i *.logrm：是否删除 一般文件 “log1.log”? yrm：是否删除 一般文件 “log2.log”? y[root@localhost test1]# ll总计 0[root@localhost test1]# 实例四：将 test1子目录及子目录中所有档案删除 命令： rm -r test1 输出：1234567891011121314151617181920212223242526272829303132333435[root@localhost test]# ll总计 24drwxr-xr-x 7 root root 4096 10-25 18:07 scfdrwxr-xr-x 2 root root 4096 10-26 14:51 test1drwxr-xr-x 3 root root 4096 10-25 17:44 test2drwxrwxrwx 2 root root 4096 10-25 17:46 test3drwxr-xr-x 2 root root 4096 10-25 17:56 test4drwxr-xr-x 3 root root 4096 10-25 17:56 test5[root@localhost test]# rm -r test1rm：是否进入目录 “test1”? yrm：是否删除 一般文件 “test1/log3.log”? yrm：是否删除 目录 “test1”? y[root@localhost test]# ll总计 20drwxr-xr-x 7 root root 4096 10-25 18:07 scfdrwxr-xr-x 3 root root 4096 10-25 17:44 test2drwxrwxrwx 2 root root 4096 10-25 17:46 test3drwxr-xr-x 2 root root 4096 10-25 17:56 test4drwxr-xr-x 3 root root 4096 10-25 17:56 test5[root@localhost test]# 实例五：rm -rf test2命令会将 test2 子目录及子目录中所有档案删除,并且不用一一确认 命令： rm -rf test2 输出：12345678910111213[root@localhost test]# rm -rf test2[root@localhost test]# ll总计 16drwxr-xr-x 7 root root 4096 10-25 18:07 scfdrwxrwxrwx 2 root root 4096 10-25 17:46 test3drwxr-xr-x 2 root root 4096 10-25 17:56 test4drwxr-xr-x 3 root root 4096 10-25 17:56 test5[root@localhost test]# 实例六：删除以 -f 开头的文件 命令： rm -- -f 输出：12345678910111213141516171819202122232425[root@localhost test]# touch -- -f[root@localhost test]# ls -- -f-f[root@localhost test]# rm -- -frm：是否删除 一般空文件 “-f”? y[root@localhost test]# ls -- -fls: -f: 没有那个文件或目录[root@localhost test]#也可以使用下面的操作步骤:[root@localhost test]# touch ./-f[root@localhost test]# ls ./-f./-f[root@localhost test]# rm ./-frm：是否删除 一般空文件 “./-f”? y[root@localhost test]# 实例七：自定义回收站功能 命令： myrm(){ D=/tmp/$(date +%Y%m%d%H%M%S); mkdir -p $D; mv &quot;$@&quot; $D &amp;&amp; echo &quot;moved to $D ok&quot;; } 输出：12345678910111213141516171819202122232425262728293031323334353637383940414243[root@localhost test]# myrm()&#123; D=/tmp/$(date +%Y%m%d%H%M%S); mkdir -p $D; mv &quot;$@&quot; $D &amp;&amp; echo &quot;moved to $D ok&quot;; &#125;[root@localhost test]# alias rm=&apos;myrm&apos;[root@localhost test]# touch 1.log 2.log 3.log[root@localhost test]# ll总计 16-rw-r--r-- 1 root root 0 10-26 15:08 1.log-rw-r--r-- 1 root root 0 10-26 15:08 2.log-rw-r--r-- 1 root root 0 10-26 15:08 3.logdrwxr-xr-x 7 root root 4096 10-25 18:07 scfdrwxrwxrwx 2 root root 4096 10-25 17:46 test3drwxr-xr-x 2 root root 4096 10-25 17:56 test4drwxr-xr-x 3 root root 4096 10-25 17:56 test5[root@localhost test]# rm [123].logmoved to /tmp/20121026150901 ok[root@localhost test]# ll总计 16drwxr-xr-x 7 root root 4096 10-25 18:07 scfdrwxrwxrwx 2 root root 4096 10-25 17:46 test3drwxr-xr-x 2 root root 4096 10-25 17:56 test4drwxr-xr-x 3 root root 4096 10-25 17:56 test5[root@localhost test]# ls /tmp/20121026150901/1.log 2.log 3.log[root@localhost test]# 说明： 上面的操作过程模拟了回收站的效果，即删除文件的时候只是把文件放到一个临时目录中， 这样在需要的时候还可以恢复过来。 参考资料： http://codingstandards.iteye.com/blog/983531]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[每天一个linux命令--mkdir]]></title>
      <url>%2F2017%2F04%2F11%2Fevery-day-linux-command4-mkdir%2F</url>
      <content type="text"><![CDATA[每天一个linux命令–mkdir文章转载自博客园，作者peida。本文仅作为自用参考，请勿转载。 linux mkdir 命令用来创建指定的名称的目录，要求创建目录的用户在当前目录中具有写权限，并且指定的目录名不能是当前目录中已有的目录。 1．命令格式：mkdir [选项] 目录... 2．命令功能：通过 mkdir 命令可以实现在指定位置创建以 DirName(指定的文件名)命名的文件夹或目录。要创建文件夹或目录的用户必须对所创建的文件夹的父文件夹具有写权限。并且，所创建的文件夹(目录)不能与其父目录(即父文件夹)中的文件名重名，即同一个目录下不能有同名的(区分大小写)。 3．命令参数：-m, --mode=模式，设定权限&lt;模式&gt; (类似 chmod)，而不是 rwxrwxrwx 减 umask -p, --parents 可以是一个路径名称。此时若路径中的某些目录尚不存在,加上此选项后, 系统将自动建立好那些尚不存在的目录,即一次可以建立多个目录; -v, --verbose 每次创建新目录都显示信息 --help 显示此帮助信息并退出 --version 输出版本信息并退出 4．命令实例：实例1：创建一个空目录 命令： mkdir test1 输出：123456789[root@localhost soft]# cd test[root@localhost test]# mkdir test1[root@localhost test]# ll总计 4drwxr-xr-x 2 root root 4096 10-25 17:42 test1[root@localhost test]# 实例2：递归创建多个目录 命令： mkdir -p test2/test22 输出：123456789101112131415[root@localhost test]# mkdir -p test2/test22[root@localhost test]# ll总计 8drwxr-xr-x 2 root root 4096 10-25 17:42 test1drwxr-xr-x 3 root root 4096 10-25 17:44 test2[root@localhost test]# cd test2/[root@localhost test2]# ll总计 4drwxr-xr-x 2 root root 4096 10-25 17:44 test22[root@localhost test2]# 实例3：创建权限为777的目录 命令： mkdir -m 777 test3 输出：1234567891011[root@localhost test]# mkdir -m 777 test3[root@localhost test]# ll总计 12drwxr-xr-x 2 root root 4096 10-25 17:42 test1drwxr-xr-x 3 root root 4096 10-25 17:44 test2drwxrwxrwx 2 root root 4096 10-25 17:46 test3[root@localhost test]# 说明： test3 的权限为rwxrwxrwx 实例4：创建新目录都显示信息 命令： mkdir -v test4 输出：1234567891011[root@localhost test]# mkdir -v test4mkdir: 已创建目录 “test4”[root@localhost test]# mkdir -vp test5/test5-1mkdir: 已创建目录 “test5”mkdir: 已创建目录 “test5/test5-1”[root@localhost test]# 实例五：一个命令创建项目的目录结构 参考：http://www.ibm.com/developerworks/cn/aix/library/au-badunixhabits.html 命令： mkdir -vp scf/{lib/,bin/,doc/{info,product},logs/{info,product},service/deploy/{info,product}} 输出：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859[root@localhost test]# mkdir -vp scf/&#123;lib/,bin/,doc/&#123;info,product&#125;,logs/&#123;info,product&#125;,service/deploy/&#123;info,product&#125;&#125;mkdir: 已创建目录 “scf”mkdir: 已创建目录 “scf/lib”mkdir: 已创建目录 “scf/bin”mkdir: 已创建目录 “scf/doc”mkdir: 已创建目录 “scf/doc/info”mkdir: 已创建目录 “scf/doc/product”mkdir: 已创建目录 “scf/logs”mkdir: 已创建目录 “scf/logs/info”mkdir: 已创建目录 “scf/logs/product”mkdir: 已创建目录 “scf/service”mkdir: 已创建目录 “scf/service/deploy”mkdir: 已创建目录 “scf/service/deploy/info”mkdir: 已创建目录 “scf/service/deploy/product”[root@localhost test]# tree scf/scf/|-- bin|-- doc| |-- info| `-- product|-- lib|-- logs| |-- info| `-- product`-- service `-- deploy |-- info `-- product12 directories, 0 files[root@localhost test]#]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[每天一个linux命令--pwd]]></title>
      <url>%2F2017%2F04%2F10%2Fevery-day-linux-command3-pwd%2F</url>
      <content type="text"><![CDATA[每天一个linux命令–pwd文章转载自博客园，作者peida。本文仅作为自用参考，请勿转载。 Linux中用pwd命令来查看”当前工作目录“的完整路径。 简单得说，每当你在终端进行操作时，你都会有一个当前工作目录。 在不太确定当前位置时，就会使用pwd来判定当前目录在文件系统内的确切位置。 1. 命令格式：pwd [选项] 2．命令功能：查看”当前工作目录“的完整路径 3．常用参数：一般情况下不带任何参数 如果目录是链接时： 格式：pwd -P 显示出实际路径，而非使用连接（link）路径。 4．常用实例：实例1：用 pwd 命令查看默认工作目录的完整路径 命令： pwd 输出：12345[root@localhost ~]# pwd/root[root@localhost ~]# 实例2：使用 pwd 命令查看指定文件夹 命令： pwd 输出：1234567[root@localhost ~]# cd /opt/soft/[root@localhost soft]# pwd /opt/soft[root@localhost soft]# 实例三：目录连接链接时，pwd -P 显示出实际路径，而非使用连接（link）路径；pwd显示的是连接路径 命令： pwd -P 输出：1234567891011[root@localhost soft]# cd /etc/init.d [root@localhost init.d]# pwd/etc/init.d[root@localhost init.d]# pwd -P/etc/rc.d/init.d[root@localhost init.d]# 实例4：/bin/pwd 命令： /bin/pwd [选项] 选项： -L 目录连接链接时，输出连接路径 -P 输出物理路径 输出：123456789101112131415[root@localhost init.d]# /bin/pwd /etc/rc.d/init.d[root@localhost init.d]# /bin/pwd --help[root@localhost init.d]# /bin/pwd -P/etc/rc.d/init.d[root@localhost init.d]# /bin/pwd -L/etc/init.d[root@localhost init.d]# 实例五：当前目录被删除了，而pwd命令仍然显示那个目录 输出：123456789101112131415161718192021222324252627[root@localhost init.d]# cd /opt/soft[root@localhost soft]# mkdir removed[root@localhost soft]# cd removed/[root@localhost removed]# pwd/opt/soft/removed[root@localhost removed]# rm ../removed -rf[root@localhost removed]# pwd/opt/soft/removed[root@localhost removed]# /bin/pwd/bin/pwd: couldn&apos;t find directory entry in “..” with matching i-node[root@localhost removed]# cd [root@localhost ~]# pwd/root[root@localhost ~]#]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vim编辑器一]]></title>
      <url>%2F2017%2F04%2F09%2Fvim-1%2F</url>
      <content type="text"><![CDATA[vim文本编辑器vi与vim vi编辑器是所有Unix及Linux系统下标准的编辑器，他就相当于windows系统中的记事本一样，它的强大不逊色于任何最新的文本编辑器。他是我们使用Linux系统不能缺少的工具。由于对Unix及Linux系统的任何版本，vi编辑器是完全相同的，学会它后，您将在Linux的世界里畅行无阻。vim 具有程序编辑的能力，可以以字体颜色辨别语法的正确性，方便程序设计；因为程序简单，编辑速度相当快速。vim可以当作vi的升级版本，他可以用多种颜色的方式来显示一些特殊的信息。vim会依据文件扩展名或者是文件内的开头信息， 判断该文件的内容而自动的执行该程序的语法判断式，再以颜色来显示程序代码与一般信息。vim里面加入了很多额外的功能，例如支持正则表达式的搜索、多文件编辑、块复制等等。 这对于我们在Linux上进行一些配置文件的修改工作时是很棒的功能。 为何要学 vi所有的Unix Like系统都会内建vi文本编辑器，其他的文本编辑器则不一定会存在；一些软件的编辑接口会主动调用vi (例如 crontab, visudo, edquota 等命令)； vi的使用基本上vi可以分为三种状态，分别是一般模式、编辑模式和命令行模式， 各模式的功能区分如下： 一般模式： 以vi打开一个文件就直接进入一般模式了(这是默认的模式)。在这个模式中， 你可以使用上下左右按键来 移动光标，你可以使用删除字符或删除整行来处理文件内容， 也可以使用复制、粘贴来处理你的文件数据。 编辑模式： 在一般模式中可以进行删除、复制、粘贴等的操作，但是却无法编辑文件的内容，只有当到你按下 【i, I, o, O, a, A, r, R】等任何一个字母之后才会进入编辑模式。这时候屏幕的左下方会出现 【INSERT或 REPLACE】的字样，此时才可以进行编辑。而如果要回到一般模式时， 则必须要按下【Esc】 即可退出编辑模式。 命令行模式： 输入【 : / ? 】三个中的任何一个，就可以将光标移动到最底下那一行。在这个模式中， 可以提供查找、读取、存盘、替换字符、离开vi、显示行号等的动作则是在此模式中完成的！ 一般模式可用的按钮说明移动光标 【h、j、k、l】，分别控制光标左、下、上、右移一格 按【ctrl+b】屏幕往&quot;后&quot;移动一页 按【ctrl+f】屏幕往&quot;前&quot;移动一页 【n&lt;space&gt;】光标向右移动n个字符 【Home】移动到这一行的最前面字符处:0数字，但不能用数字小键盘上的数字 【End】 移动到这一行的最后面字符处:$，我测试好像不行 【w】光标跳到下个字的开头 【e】光标跳到下个字的字尾 【H】 光标移动到这个屏幕的最上方那一行的第一个字符 【M】 光标移动到这个屏幕的中间那一行的第一个字符 【L】光标移动到这个屏幕的最下方那一行的第一个字符 【G】 移动到这个文件的最后一行 【nG】移动到这个文件的第n行(可配合:set nu) 【gg】 移动到这个文件的第一行，相当于1G 【n&lt;Enter&gt;】光标向下移动n行 查找与替换 【/word】 向光标向下寻找一个名称为word的字符串 【?word】 向光标向上寻找一个名称为word的字符串 【n】 代表重复前一个查找的动作 【N】 与n刚好相反，为【反向】进行行前一个查找动作 【:n1,n2s/word1/word2/g】 n1与n2为数字，在第n1与n2行之间查找 word1 这个字符串，并将该字符串替换为word2 【:1,$s/word1/word2/g】 从第一行到最后一行查找word1字符串，并将该字符串替换为word2 【:1,$s/word1/word2/gc】 从第一行到最后一行查找word1字符串，并将该字符串替换为word2 ， 且在替换前提示用户确认是否进行替换删除、复制与粘贴 【x】 为向后删除一个字符 (相当于【del】键) 【X】 为向前删除一个字符(相当于【backspace】键) 【nx】 连续向后删除n个字符 【dd】 删除光标所在行 【ndd】 删除光标所在的向下n行 【d1G】 删除光标所在行到第一行的所有数据 【dG】 删除光标所在到最后一行的所有数据 【d$】 删除光标所在处，到该行的最后一个字符 【d0】 删除光标所在处，到该行的最前一个字符 【yy】 复制光标所在的那一行 【nyy】 复制光标所在的向下n列 【y1G】 复制光标所在行到第一行的所有数据 【yG】 复制光标所在行到最后一行的所有数据 【y0】 复制光标所在的那个字符到该行行首的所有数据 【y$】 复制光标所在的那个字符到该行行尾的所有数据 【p】将已复制的数据在光标下一行粘贴上 【P】 则为贴在光标的上一行 【u】 恢复前一个操作 【Ctrl+r】重做上一个操作 【.】 是重复前一个操作 一般模式切换到编辑模式的可用的按钮说明 【i, I】 进入编辑模式： i 为【从目前光标所在处插入】 I 为【在目前所在行的第一个非空格符处开始插入】 【a, A】 进入编辑模式(Insert mode)： a 为【从目前光标所在的下一个字符处开始插入】 A 为【从光标所在行的最后一个字符处开始插入】 【o, O】 进入编辑模式： o 为【在目前光标所在的下一行处插入新的一行】 O 为在目前光标所在处的上一行插入新的一行 【r, R】 进入取代模式： r 只会取代光标所在的那一个字符一次 R会一直取代光标所在的文字，直到按下 ESC 为止； 【Esc】 退出编辑模式，回到一般模式 一般模式切换到命令行模式可用的按钮说明 【:w】 保存编辑的内容 【:w!】强制写入该文件，但跟你对该文件的权限有关 【:q】 离开vi 【:q!】 不想保存修改强制离开 【:wq】 保存后离开 【:x】 保存后离开 【ZZ】 若文件没有更动，则不保存离开，若文件已经被更改过，则保存后离开 【:w filename】 将编辑的数据保存成另一个文件（类似另存） 【:r filename】 在编辑的数据中，读入另一个文件的数据。即将【filename】 这个文件的内容加到光标所在 行后面。 【:n1,n2 w filename】 将n1到n2的内容保存成filename这个文件。 【:! command】暂时离开vi 到命令行模式下执行command的显示结果！ 例如 【:! ls /home】即可在 vi 当中察看/home底下以ls输出的文件信息！ 【:set nu】 显示行号 【:set nonu】 与 set nu 相反，为取消行 vim的功能 其实，目前大部分的Linux发行版本都以vim取代了vi。为什么要用vim呢？因为vim具有颜色显示的功能，并且还支持许多的程序语法(syntax)和相应的提示信息。查看自己的VI是不是被VIM代替，可以用alias这个命令来查看是不是有alias vi=’vim’这一行。 块选择 【v】字符选择，会将光标经过的地方反白选择 【V】 行选择，会将光标经过的行反白选择 【Ctrl+v】 块选择，可以用长方形的方式选择资料 （提制竖列） 【y】 将反白的地方复制 【d】 将反白的地方删除 多文件编辑 大家在使用vim的时候，可能会碰到你需要复制一个文件中的某段到另外一个文件中， 而vim不能够在关闭的时候，把这段保留住。或者是用其它的方法复制。 【vim file1 file2】 【:n】编辑下一个文件 【:N】编辑上一个文件 【:files】列出目前这个vim编辑的所有文件 多窗口功能 有两个需要对照着看的文件 【:sp filename】开启一个新窗口，如果有加 filename， 表示在新窗口开启一个新文件，否则表示两个窗口为 同一个文件内容(同步显示)。 【ctrl+w+j】 【ctrl+w+↓】按键的按法是：先按下 【ctrl】 不放， 再按下 w 后放开所有的按键，然后再按下 j (或向下箭头键)，则光标可移动到下方的窗口。 【ctrl+w+k】 【ctrl+w+↑】同上，不过光标移动到上面的窗口。 vim 环境设定与记录(~/.vimrc, ~/.viminfo) 如果我们以vim软件来查找一个文件内部的某个字符串时，这个字符串会被反白， 而下次我们再次以vim编辑这个文件时，该查找的字符串反白情况还是存在。另外，当我们重复编辑同一个文件时，当第二次进入该文件时， 光标竟然就在上次离开的那一行的开头。这个功能可能是方便，但也有不方便的时候。怎么会这样呢？这是因为我们的vim会主动的将你曾经做过的行为登录下来，那个记录动作的文件就是： ~/.viminfo，不想用这个功能，就直接删除~/.viminfo。只要你曾经使用过vim，那么你的家目录就会有这个文件。这个文件是自动产生的，你在vim里头所做过的动作，就可以在这个文件内部找到。有兴趣的朋友可以自己查看文件里面的内容。 不过，对于每个不同的发行版本对vim的预设环境都不太相同。举例来说，某些版本在查找到关键词时并不会高亮度反白， 有些版本则会主动的帮你进行缩排（所谓的缩排，就是当你按下 Enter 编辑新的一行时，光标不会在行首，而是在与上一行的第一个非空格符处对齐）的行为。其实这些都可以自行设定的，下面我们就来看看vim的环境设定。 vim的环境设定参数有很多，如果你想要知道目前的设定值，可以在一般模式时输入【 :set all】来查阅，由于设定项目实在太多了，我们在这里就仅列出一些平时比较常用的一些简单的设定值，给大家提供参考。 :set all &quot;显示目前所有的环境参数设定值 :set hlsearch &quot;高亮度反白(高亮度搜寻) :set nohlsearch &quot;取消高亮度反白(高亮度搜寻) :set backspace=2 &quot;在编辑的时候可随时用退格键删除 （０、１的时候，只针对刚输入的字符有效） :set autoindent &quot;自动缩排 :set noautoindent &quot;取消自动缩排 :set ruler &quot;可显示最后一行的状态 :set showmode &quot;左下角那一行的状态 :set nu &quot;显示行号 :set nonu &quot;取消行号 :set bg=dark &quot;显示不同的底色色调 :syntax on &quot;进行语法检验，颜色显示 :syntax off &quot;关闭语法检验 了解完上面的内容后，下面我们就能写一下自己的vim操作环境。整体vim的设定值一般是置在/etc/vimrc这个文件里面，不建议大家来修改他。我们在自己的家目录里面建立个.vimrc文件，在这里面写入自己的内容就能实现了。1234567891011[root@yufei ~]# vim ~/.vimrc内容如下set hlsearch &quot;高亮度反白set backspace=2 &quot;可随时用退格键删除set autoindent &quot;自动缩排set ruler &quot;可显示最后一行的状态set showmode &quot;左下角那一行的状态set nu &quot;可以在每一行的最前面显示行号set bg=dark &quot;显示不同的底色色调syntax on &quot;进行语法检验，颜色显示&quot;这个文件的双引号 (&quot;)表示的是注释 保存退出vim后，在下次使用vim的时候，就会有自己的vim操作环境了。提醒一点，这个文件中每一行前面加不加【:】效果都是一样的。 转自：http://blog.csdn.net/xiaolong2w/article/details/8224839]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[vim编辑器二]]></title>
      <url>%2F2017%2F04%2F09%2Fvim-2%2F</url>
      <content type="text"><![CDATA[vim 文本编辑器二linux vim编辑器必知必会一、我们为什么要学习vim编辑器？ Linux的命令行界面下面有非常多的文本编辑器。比如经常听说的就有Emacs、pico、nano、joe与vim等。vim可以看做是vi的高级版。我们为什么一定要学习vim呢？有以下几个原因： (1)所有的Unix like系统都会内置vi文本编辑器，其他的文本编辑器则不一定会存在。 (2)很多软件的编辑接口都会主动调用vi。 (3)vim具有程序编辑的能力，可以主动以字体颜色辨别语法的正确性，方便程序设计。 (4)程序简单，编辑速度快。 二、下面先介绍一下vi的基本使用方法及其相关命令。vim编辑器的三种模式：一般模式、编辑模式和命令行模式。 在一般模式中可以进行删除、复制和粘贴的功能，但是无法编辑文件内容。从一般模式切换到编辑模式可以按下i、I、o、O、a、A、r、R键。按下Esc键可以回到一般模式。在一般模式中输入：、/、？三个中的任意一个可以将光标移到最下面的一行。在这个模式中可以提供查找数据的操作，而读取、保存、大量替换字符、离开vii、显示行号等操作则是在此模式中完成的。需要注意的是，编辑模式与命令行模式之间是不能互相切换的。 下面列出平时用的最多的vi命令： 移动光标的方法： [Ctrl]+[f]：屏幕向下移动一页，相当于[PageDown]按键。 [Ctrl]+[b]：屏幕向上移动一页，相当于[PageUp]按键。 0或功能键[Home]：移动到这一行的最前面字符处。 $或功能键[End]：移动到这一行的最后面字符处。 G：移动到这个文件的最后一行。 gg：移动到这个文件的第一行，相当于1G. N[Enter]：N为数字，光标向下移动N行。 查找和替换： /word：向下寻找一个名称为word的字符串。 ?word：向上寻找一个名称为word的字符串。 :n1,n2s/word1/word2/g：在第n1行和n2行之间寻找word1这个字符串，并且将其替换为word2. :1,$s/word1/word2/g：从第一行到最后一行寻找word1这个字符串，并且将其替换为word2. :1,$s/word1/word2/gc：从第一行到最后一行寻找word1这个字符串，并且将其替换为word2. 且在替换前显示提示字符给用户确认是否需要替换。 删除、复制和粘贴： x,X：在一行字中，x为向后删除一个字符（相当于[Del]键），X为向前删除一个字符（相当于[Backspace]）。 dd：删除光标所在的一整行。 ndd：删除光标所在的向下n行。 yy：复制光标所在的一行。 nyy：复制光标所在的向下n行。 p,P：p为将已复制的内容在光标的下一行粘贴，P则为粘贴在光标的上一行。 u：复原前一个操作。 [Ctrl]+r：重做上一个操作。 .：小数点，重复前一个操作。 一般模式切换到编辑模式： i,I：进入插入模式，i为从目前光标所在处插入。I为在目前所在行的第一个非空格字符处开始插入。 a，A：进入插入模式。a为从目前光标所在处的下一个字符处开始插入。A为从所在行的最后一个字符处开始插入。 o，O：进入插入模式。o为在下一行插入。O为在上一行插入。 r，R：进入替换模式。r只替换光标所在那个字符一次。R会一直替换光标所在字符，直到按下Esc键。 一般模式切换到命令行： :w：将编辑的数据写入到硬盘中。 :q：离开vi.后面加！为强制离开。 :wq：保存后离开。:wq!为强制保存后离开。 目前主要的编辑器都有恢复功能，vim也不例外。vim是通过“保存”文件来挽回数据的。 每当我们在用vim编辑时，vim都会自动在被编辑的文件的目录下面再新建一个名为filename.swap的文件。这就是一个暂存文件，我们对文件filename所做的操作都会被记录到这个文件当中。如果系统意外崩溃，导致文件没有正常保存，那么这个暂存文件就会发挥作用。下面用一个例子来说明(Note：我用的是Ubuntu)。1234567打开终端，输入命令，将etc目录下面的manpath.config复制到tmp目录下面，并且更改当前工作目录为tmp：cp /etc/manpath.config /tmpcd /tmp用vim编辑manpath.config文件：vim manpath.config。 我们在vim的一般模式下按下Ctrl+z组合键，vim就会被丢到后台执行。回到命令提示符环境后，我们模拟将vim的工作不正常中断。 kill -9 %1;强制杀死制定的进程。 这样导致暂存盘无法通过正常的流程结束，所以暂存文件不会消失，而是继续保留下来。当再次编辑那个文件时(输入命令vim manpath.config)，出现(ubuntu 11.10)： 这时，有六个按钮可以使用： O(pen for Read-Only):打开成只读文件。 E(dit):用正常方式打开要编辑的文件，并不会载入暂存文件的内容。这很容易出现两个用户相互改变对方的文件 的问题。 R(ecover)：加载暂存文件的内容。 D(elete)：如果你确定这个暂存文件是没有用的，则可以删除。 Q(uit)：不进行任何操作，回到命令行。 A(bort)：忽略这个编辑行为，和Q类似。 需要注意的是：这个暂存文件不会应为你结束vim后自动删除，必须要手动删除。否则每次打开对应的文件时都会出现这样的提示。 转自：http://blog.csdn.net/xiaolong2w/article/details/8224839]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[每天一个linux命令--cd]]></title>
      <url>%2F2017%2F04%2F09%2Fevery-day-linux-command2.cd%2F</url>
      <content type="text"><![CDATA[每天一个linux命令–cd文章转载自博客园，作者peida。本文仅作为自用参考，请勿转载。 cd命令可以说是Linux中最基本的命令语句，其他的命令语句要进行操作，都是建立在使用 cd 命令上的。 所以，学习Linux 常用命令，首先就要学好 cd 命令的使用方法技巧。 1. 命令格式：cd [目录名] 2. 命令功能：切换当前目录至dirName 3. 常用范例：3.1 例一：进入系统根目录 命令： cd / 输出：1[root@localhost ~]# cd / 说明：进入系统根目录,上面命令执行完后拿ls命令看一下，当前目录已经到系统根目录了 命令： cd .. 或者 cd .. // 输出:123456[root@localhost soft]# pwd/opt/soft[root@localhost soft]# cd ..[root@localhost opt]# cd ..//[root@localhost /]# pwd/ 说明： 进入系统根目录可以使用“ cd .. ”一直退，就可以到达根目录 命令： cd ../.. // 输出：123456[root@localhost soft]# pwd/opt/soft[root@localhost soft]# cd ../.. //[root@localhost /]# pwd/[root@localhost /]# 说明：使用cd 命令实现进入当前目录的父目录的父目录。 例2：使用 cd 命令进入当前用户主目录 “当前用户主目录”和“系统根目录”是两个不同的概念。进入当前用户主目录有两个方法。 命令1： cd 输出：12345[root@localhost soft]# pwd/opt/soft[root@localhost soft]# cd[root@localhost ~]# pwd/root 命令2： cd ~ 输出：123456[root@localhost ~]# cd /opt/soft/[root@localhost soft]# pwd/opt/soft[root@localhost soft]# cd ~[root@localhost ~]# pwd/root 例3：跳转到指定目录 命令： cd /opt/soft 输出：1234567[root@localhost ~]# cd /opt/soft[root@localhost soft]# pwd/opt/soft[root@localhost soft]# cd jdk1.6.0_16/[root@localhost jdk1.6.0_16]# pwd/opt/soft/jdk1.6.0_16[root@localhost jdk1.6.0_16]# 说明： 跳转到指定目录，从根目录开始，目录名称前加 / ,当前目录内的子目录直接写名称即可 例四：返回进入此目录之前所在的目录 命令： cd - 输出： 123456789[root@localhost soft]# pwd/opt/soft[root@localhost soft]# cd -/root[root@localhost ~]# pwd/root[root@localhost ~]# cd -/opt/soft[root@localhost soft]# 例五：把上个命令的参数作为cd参数使用。 命令： cd !$ 输出： 1234567[root@localhost soft]# cd !$cd -/root[root@localhost ~]# cd !$cd -/opt/soft[root@localhost soft]#]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[每天一个linux命令--ls]]></title>
      <url>%2F2017%2F04%2F08%2Fevery-day-linux-command1.ls%2F</url>
      <content type="text"><![CDATA[每天一个linux命令–ls文章转载自博客园，作者peida。本文仅作为自用参考，请勿转载。 ls命令是linux下最常用的命令。ls命令就是list的缩写缺省下ls用来打印出当前目录的清单,如果ls指定其他目录,那么就会显示指定目录里的文件及文件夹清单。 通过ls 命令不仅可以查看linux文件夹包含的文件而且可以查看文件权限(包括目录、文件夹、文件权限),查看目录信息等等。ls 命令在日常的linux操作中用的很多! 1. 命令格式：ls [选项] [目录名] 2. 命令功能：列出目标目录中所有的子目录和文件。 3. 常用参数：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788-a –all 列出目录下的所有文件，包括以 . 开头的隐含文件 -A 同-a，但不列出“.”(表示当前目录)和“..”(表示当前目录的父目录)。 -c 配合 -lt：根据 ctime 排序及显示 ctime (文件状态最后更改的时间) 配合 -l：显示 ctime 但根据名称排序否则：根据 ctime 排序 -C 每栏由上至下列出项目 –color[=WHEN] 控制是否使用色彩分辨文件。WHEN 可以是&apos;never&apos;&apos;always&apos;或&apos;auto&apos;其中之一 -d –directory 将目录象文件一样显示，而不是显示其下的文件。 -D –dired 产生适合 Emacs 的 dired 模式使用的结果 -f 对输出的文件不进行排序，-aU 选项生效，-lst 选项失效 -g 类似 -l,但不列出所有者 -G –no-group 不列出任何有关组的信息 -h –human-readable 以容易理解的格式列出文件大小 (例如 1K 234M 2G) –si 类似 -h,但文件大小取 1000 的次方而不是 1024 -H –dereference-command-line 使用命令列中的符号链接指示的真正目的地 –indicator-style=方式 指定在每个项目名称后加上指示符号 &lt;方式&gt;：none (默认)，classify (-F)，file-type (-p) -i –inode 印出每个文件的 inode 号 -I –ignore=样式 不印出任何符合 shell 万用字符&lt;样式&gt;的项目 -k 即 –block-size=1K,以 k 字节的形式表示文件的大小。 -l 除了文件名之外，还将文件的权限、所有者、文件大小等信息详细列出来。 -L –dereference 当显示符号链接的文件信息时，显示符号链接所指示的对象而并非符号 链接本身的信息 -m 所有项目以逗号分隔，并填满整行行宽 -o 类似 -l,显示文件的除组信息外的详细信息。 -r –reverse 依相反次序排列 -R –recursive 同时列出所有子目录层 -s –size 以块大小为单位列出所有文件的大小 -S 根据文件大小排序 –sort=WORD 以下是可选用的 WORD 和它们代表的相应选项： extension -X status -c none -U time -t size -S atime -u time -t access -u version -v use -u -t 以文件修改时间排序 -u 配合 -lt:显示访问时间而且依访问时间排序 配合 -l:显示访问时间但根据名称排序 否则：根据访问时间排序 -U 不进行排序;依文件系统原有的次序列出项目 -v 根据版本进行排序 -w –width=COLS 自行指定屏幕宽度而不使用目前的数值 -x 逐行列出项目而不是逐栏列出 -X 根据扩展名排序 -1 每行只列出一个文件 –help 显示此帮助信息并离开 –version 显示版本信息并离开 4. 常用范例：例一：列出/home/peidachang文件夹下的所有文件和目录的详细资料 命令：ls -l -R /home/peidachang 在使用 ls 命令时要注意命令的格式：在命令提示符后，首先是命令的关键字，接下来是命令参数，在命令参数之前要有一短横线“-”，所有的命令参数都有特定的作用，自己可以根据需要选用一个或者多个参数，在命令参数的后面是命令的操作对象。在以上这条命令“ ls -l -R /home/peidachang”中，“ls” 是命令关键字，“-l -R”是参数，“ /home/peidachang”是命令的操作对象。在这条命令中，使用到了两个参数，分别为“l”和“R”，当然，你也可以把他们放在一起使用，如下所示： 命令：ls -lR /home/peidachang 这种形式和上面的命令形式执行的结果是完全一样的。另外，如果命令的操作对象位于当前目录中，可以直接对操作对象进行操作;如果不在当前目录则需要给出操作对象的完整路径，例如上面的例子中，我的当前文件夹是peidachang文件夹，我想对home文件夹下的peidachang文件进行操作，我可以直接输入 ls -lR peidachang，也可以用 ls -lR /home/peidachang。 例二：列出当前目录中所有以“t”开头的目录的详细内容，可以使用如下命令： 命令：ls -l t* 可以查看当前目录下文件名以“t”开头的所有文件的信息。其实，在命令格式中，方括号内的内容都是可以省略的，对于命令ls而言，如果省略命令参数和操作对象，直接输入“ ls ”，则将会列出当前工作目录的内容清单。 例三：只列出文件下的子目录 命令：ls -F /opt/soft |grep /$ 列出 /opt/soft 文件下面的子目录 输出：1234567[root@localhost opt]# ls -F /opt/soft |grep /$jdk1.6.0_16/subversion-1.6.1/tomcat6.0.32/ 命令：ls -l /opt/soft | grep &quot;^d&quot; 列出 /opt/soft 文件下面的子目录详细情况 输出：1234567[root@localhost opt]# ls -l /opt/soft | grep &quot;^d&quot;drwxr-xr-x 10 root root 4096 09-17 18:17 jdk1.6.0_16drwxr-xr-x 16 1016 1016 4096 10-11 03:25 subversion-1.6.1drwxr-xr-x 9 root root 4096 2011-11-01 tomcat6.0.32 例四：列出目前工作目录下所有名称是s 开头的档案，愈新的排愈后面，可以使用如下命令： 命令：ls -ltr s* 输出：1234567891011121314151617181920212223242526272829[root@localhost opt]# ls -ltr s*src:总计 0script:总计 0soft:总计 350644drwxr-xr-x 9 root root 4096 2011-11-01 tomcat6.0.32-rwxr-xr-x 1 root root 81871260 09-17 18:15 jdk-6u16-linux-x64.bindrwxr-xr-x 10 root root 4096 09-17 18:17 jdk1.6.0_16-rw-r--r-- 1 root root 205831281 09-17 18:33 apache-tomcat-6.0.32.tar.gz-rw-r--r-- 1 root root 5457684 09-21 00:23 tomcat6.0.32.tar.gz-rw-r--r-- 1 root root 4726179 10-10 11:08 subversion-deps-1.6.1.tar.gz-rw-r--r-- 1 root root 7501026 10-10 11:08 subversion-1.6.1.tar.gzdrwxr-xr-x 16 1016 1016 4096 10-11 03:25 subversion-1.6.1 例五：列出目前工作目录下所有档案及目录;目录于名称后加”/“, 可执行档于名称后加”*” 命令：ls -AF 输出：123[root@localhost opt]# ls -AFlog/ script/ soft/ src/ svndata/ web/ 例六：计算当前目录下的文件数和目录数 命令： ls -l * |grep &quot;^-&quot;|wc -l ---文件个数 ls -l * |grep &quot;^d&quot;|wc -l ---目录个数 例七: 在ls中列出文件的绝对路径 命令：ls | sed &quot;s:^:`pwd`/:&quot; 输出：12345678910111213[root@localhost opt]# ls | sed &quot;s:^:`pwd`/:&quot; /opt/log/opt/script/opt/soft/opt/src/opt/svndata/opt/web 例九：列出当前目录下的所有文件（包括隐藏文件）的绝对路径， 对目录不做递归 命令：find $PWD -maxdepth 1 | xargs ls -ld 输出：123456789101112131415[root@localhost opt]# find $PWD -maxdepth 1 | xargs ls -lddrwxr-xr-x 8 root root 4096 10-11 03:43 /optdrwxr-xr-x 2 root root 4096 2012-03-08 /opt/logdrwxr-xr-x 2 root root 4096 2012-03-08 /opt/scriptdrwxr-xr-x 5 root root 4096 10-11 03:21 /opt/softdrwxr-xr-x 2 root root 4096 2012-03-08 /opt/srcdrwxr-xr-x 4 root root 4096 10-11 05:22 /opt/svndatadrwxr-xr-x 4 root root 4096 10-09 00:45 /opt/web 例十：递归列出当前目录下的所有文件（包括隐藏文件）的绝对路径 命令： find $PWD | xargs ls -ld 例十一：指定文件时间输出格式 命令： ls -tl --time-style=full-iso 输出：12345[root@localhost soft]# ls -tl --time-style=full-iso 总计 350644drwxr-xr-x 16 1016 1016 4096 2012-10-11 03:25:58.000000000 +0800 subversion-1.6.1 命令： ls -ctl --time-style=long-iso 输出：12345[root@localhost soft]# ls -ctl --time-style=long-iso总计 350644drwxr-xr-x 16 1016 1016 4096 2012-10-11 03:25 subversion-1.6.1 扩展： 显示彩色目录列表 打开/etc/bashrc, 加入如下一行: alias ls=&quot;ls --color&quot; 下次启动bash时就可以像在Slackware里那样显示彩色的目录列表了, 其中颜色的含义如下: 1. 蓝色--&gt;目录 2. 绿色--&gt;可执行文件 3. 红色--&gt;压缩文件 4. 浅蓝色--&gt;链接文件 5. 灰色--&gt;其他文件]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[linux COMMAND]]></title>
      <url>%2F2017%2F04%2F06%2Flinux-COMMAND%2F</url>
      <content type="text"><![CDATA[Linux常用命令1.线上帮助man help 2.目录操作ls tree pwd mkdir rmdir cd 3.文件操作touch cp mv rm ln find rename 4.文件查看处理cat more less head tail cut paste sort uniq wc iconv dos2unix file diff tree chattr lsattr rev vimdiff 5.文件打包压缩gzip tar unzip 6.信息显示uname hostname dmesg uptime file stat du df top free w date 7.搜索命令find which whereis locate 8.用户管理useradd userdel passwd chage usermod id. su sudo visudo groupadd 9.网络操作telent ssh scp wget ping route ifconfig ifup ifdown netstat curl lynx mail mutt nslookup dig 10.磁盘空间mount umount df du fsck dd 11.关机和查看系统命令shutdown reboot ps top kill date halt 12.系统管理top vmstat mpstat iostat sar kill chkconfig last 13.系统安全passwd su sudo umask charg chmod chattr lsattr ps whoami 14.系统登录信息w who users last lastlog fingers 15.硬件信息查看ethtool mii-tool dmidecode dmesg lspci 16.其他chkconfig echo yum watch alias unlias clear history eject time nohup nc xargs 17.关机shuatdown -h now init 0 halt -p 18.进程bg fg jobs kill，killall，pkill crontab ps pstree top nice nohup pgrep strace 19.危险命令mv rm fdisk dd parted 20.文本四剑客grep egrep sed awk]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[grep和正则表达式]]></title>
      <url>%2F2017%2F04%2F06%2Fgrep-and-zhengze%2F</url>
      <content type="text"><![CDATA[grep命令及正则表达式以下转自微信公众号：magedu-Linux grep基本概念 grep：global search regular expression and print out the line 作用：文本过滤器，用于文本搜索，用指定“模式”逐行匹配。 模式：由正则表达式字符及文本字符所编写的过滤条件 正则表达式：由一类特殊字符和文本字符所编写的模式，其有些字符不表示字符字面意义，而表示控制或通配的功能 比较记忆： 基本正则表达式：BRE 扩展正则表达式：ERE grep -E = egrep grep语法 grep [OPTIONS] PATTERN [FILE…] OPTIONS：1234567891011121314151617--color=auto：对匹配到的文本着色后高亮显示；-i：ignorecase，忽略字符的大小写；-o：仅显示匹配到的字符串本身；-v, --invert-match：显示不能被模式匹配到的行；-E：支持使用扩展的正则表达式元字符；-q, --quiet, --silent：静默模式，即不输出任何信息；-A #：after, 后#行-B #：before，前#行 -C #：context，前后各#行 基本正则表达式原字符字符匹配： . ：匹配任意单个字符； []：匹配指定范围内的任意单个字符； [^]：匹配指定范围外的任意单个字符； [:digit:]、[:lower:]、[:upper:]、[:alpha:]、[:alnum:]、[:punct:]、[:space:] 匹配次数： 用在要指定其出现的次数的字符的后面，用于限制其前面字符出现的次数；默认工作于贪婪模式； *：匹配其前面的字符任意次；0,1,多次； 例如：grep &quot;x\+y&quot; abxy aby xxxxxy yab .*：匹配任意长度的任意字符 \?：匹配其前面的字符0次或1次；即其前面的字符是可有可无的； \+：匹配其前面的字符1次或多次；即其面的字符要出现至少1次； \{m\}：匹配其前面的字符m次； \{m,n\}：匹配其前面的字符至少m次，至多n次； \{0,n\}：至多n次 \{m,\}：至少m次 位置锚定： ^：行首锚定；用于模式的最左侧； $：行尾锚定；用于模式的最右侧； ^PATTERN$：用于PATTERN来匹配整行； ^$：空白行； ^[[:space:]]*$：空行或包含空白字符的行； \&lt; 或 \b：词首锚定，用于单词模式的左侧； > 或 \b：词尾锚定，用于单词模式的右侧； \：匹配完整单词； 单词：非特殊字符组成的连续字符（字符串）都称为单词； 分组及引用 ()：将一个或多个字符捆绑在一起，当作一个整体进行处理； \(xy\)*ab Note：分组括号中的模式匹配 到的内容会被正则表达式引擎自动记录于内部的变量中，这些变量为： \1：模式从左侧起，第一个左括号以及与之匹配的右括号之间的模式所匹配到的字符； \2：模式从左侧起，第二个左括号以及与之匹配的右括号之间的模式所匹配到的字符； \3 … He loves his lover. He likes his lover. She likes her liker. She loves her liker. ~]# grep &quot;\(l..e\).*\1&quot; lovers.txt 后向引用：引用前面的分组括号中的模式所匹配到的字符； 扩展正则表达式的元字符字符匹配： .：任意单个字符 []：指定范围内的任意单个字符 [^]：指定范围外的任意单个字符 次数匹配： *：任意次，0,1或多次； ?：0次或1次，其前的字符是可有可无的； +：其前字符至少1次； {m}：其前的字符m次； {m,n}：至少m次，至多n次; {0,n} {m,} 位置锚定： ^：行首锚定； $：行尾锚定； \&lt;, \b：词首锚定； \&gt;, \b：词尾锚定； 分组及引用： ()：分组；括号内的模式匹配到的字符会被记录于正则表达式引擎的内部变量中； 后向引用：\1, \2, ... 或： a|b：a或者b；C|cat：C或cat(c|C)at：cat或Cat]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常用正则表达式集合]]></title>
      <url>%2F2017%2F04%2F06%2Fzhengzebiaodashi%2F</url>
      <content type="text"><![CDATA[常用正则表达式集合以下转载自微信公众号：ChinaHadoop 校验数字的表达式 数字：^[0-9]*$ n位的数字：^\d{n}$ 至少n位的数字：^\d{n,}$ m-n位的数字：^\d{m,n}$ 零和非零开头的数字：^(0|[1-9][0-9]*)$ 非零开头的最多带两位小数的数字：^([1-9][0-9]*)+(.[0-9]{1,2})?$ 带1-2位小数的正数或负数：^(-)?\d+(.\d{1,2})?$ 正数、负数、和小数：^(-|+)?\d+(.\d+)?$ 有两位小数的正实数：^[0-9]+(.[0-9]{2})?$ 有1~3位小数的正实数：^[0-9]+(.[0-9]{1,3})?$ 非零的正整数：^[1-9]\d$ 或 ^([1-9][0-9]){1,3}$ 或 ^+?[1-9][0-9]*$ 非零的负整数：^-[1-9][]0-9”$ 或 ^-[1-9]\d$ 非负整数：^\d+$ 或 ^[1-9]\d*|0$ 非正整数：^-[1-9]\d*|0$ 或 ^((-\d+)|(0+))$ 非负浮点数：^\d+(.\d+)?$ 或 ^[1-9]\d.\d|0.\d[1-9]\d|0?.0+|0$ 非正浮点数：^((-\d+(.\d+)?)|(0+(.0+)?))$ 或 ^(-([1-9]\d.\d|0.\d[1-9]\d))|0?.0+|0$ 正浮点数：^[1-9]\d.\d|0.\d[1-9]\d$ 或 ^(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9]))$ 负浮点数：^-([1-9]\d.\d|0.\d[1-9]\d)$ 或 ^(-(([0-9]+.[0-9][1-9][0-9])|([0-9][1-9][0-9].[0-9]+)|([0-9][1-9][0-9])))$ 浮点数：^(-?\d+)(.\d+)?$ 或 ^-?([1-9]\d.\d|0.\d[1-9]\d|0?.0+|0)$ 校验字符的表达式 汉字：^[\u4e00-\u9fa5]{0,}$ 英文和数字：^[A-Za-z0-9]+$ 或 ^[A-Za-z0-9]{4,40}$ 长度为3-20的所有字符：^.{3,20}$ 由26个英文字母组成的字符串：^[A-Za-z]+$ 由26个大写英文字母组成的字符串：^[A-Z]+$ 由26个小写英文字母组成的字符串：^[a-z]+$ 由数字和26个英文字母组成的字符串：^[A-Za-z0-9]+$ 由数字、26个英文字母或者下划线组成的字符串：^\w+$ 或 ^\w{3,20}$ 中文、英文、数字包括下划线：^[\u4E00-\u9FA5A-Za-z0-9_]+$ 中文、英文、数字但不包括下划线等符号：^[\u4E00-\u9FA5A-Za-z0-9]+$ 或 ^[\u4E00-\u9FA5A-Za-z0-9]{2,20}$ 可以输入含有^%&amp;’,;=?$\”等字符：[^%&amp;’,;=?$\x22]+ 12 禁止输入含有~的字符：[^~\x22]+ 特殊需求表达式 Email地址：^\w+([-+.]\w+)@\w+([-.]\w+).\w+([-.]\w+)*$ 域名：[a-zA-Z0-9][-a-zA-Z0-9]{0,62}(/.[a-zA-Z0-9][-a-zA-Z0-9]{0,62})+/.? InternetURL：[a-zA-z]+://[^\s] 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=])?$ 手机号码：^(13[0-9]|14[5|7]|15[0|1|2|3|5|6|7|8|9]|18[0|1|2|3|5|6|7|8|9])\d{8}$ 电话号码(“XXX-XXXXXXX”、”XXXX-XXXXXXXX”、”XXX-XXXXXXX”、”XXX-XXXXXXXX”、”XXXXXXX”和”XXXXXXXX)：^((\d{3,4}-)|\d{3.4}-)?\d{7,8}$ 国内电话号码(0511-4405222、021-87888822)：\d{3}-\d{8}|\d{4}-\d{7} 身份证号(15位、18位数字)：^\d{15}|\d{18}$ 短身份证号码(数字、字母x结尾)：^([0-9]){7,18}(x|X)?$ 或 ^\d{8,18}|[0-9x]{8,18}|[0-9X]{8,18}?$ 帐号是否合法(字母开头，允许5-16字节，允许字母数字下划线)：^[a-zA-Z][a-zA-Z0-9_]{4,15}$ 密码(以字母开头，长度在6~18之间，只能包含字母、数字和下划线)：^[a-zA-Z]\w{5,17}$ 强密码(必须包含大小写字母和数字的组合，不能使用特殊字符，长度在8-10之间)：^(?=.\d)(?=.[a-z])(?=.*[A-Z]).{8,10}$ 日期格式：^\d{4}-\d{1,2}-\d{1,2} 一年的12个月(01～09和1～12)：^(0?[1-9]|1[0-2])$ 一个月的31天(01～09和1～31)：^((0?[1-9])|((1|2)[0-9])|30|31)$ 钱的输入格式： 有四种钱的表示形式我们可以接受:”10000.00” 和 “10,000.00”, 和没有 “分” 的 “10000” 和 “10,000”：^[1-9][0-9]*$ 这表示任意一个不以0开头的数字,但是,这也意味着一个字符”0”不通过,所以我们采用下面的形式：^(0|[1-9][0-9]*)$ 一个0或者一个不以0开头的数字.我们还可以允许开头有一个负号：^(0|-?[1-9][0-9]*)$ 这表示一个0或者一个可能为负的开头不为0的数字.让用户以0开头好了.把负号的也去掉,因为钱总不能是负的吧.下面我们要加的是说明可能的小数部分：^[0-9]+(.[0-9]+)?$ 必须说明的是,小数点后面至少应该有1位数,所以”10.”是不通过的,但是 “10” 和 “10.2” 是通过的：^[0-9]+(.[0-9]{2})?$ 这样我们规定小数点后面必须有两位,如果你认为太苛刻了,可以这样：^[0-9]+(.[0-9]{1,2})?$ 这样就允许用户只写一位小数.下面我们该考虑数字中的逗号了,我们可以这样：^[0-9]{1,3}(,[0-9]{3})*(.[0-9]{1,2})?$ 1到3个数字,后面跟着任意个 逗号+3个数字,逗号成为可选,而不是必须：^([0-9]+|[0-9]{1,3}(,[0-9]{3})*)(.[0-9]{1,2})?$ 备注：这就是最终结果了,别忘了”+”可以用”*”替代如果你觉得空字符串也可以接受的话(奇怪,为什么?)最后,别忘了在用函数时去掉去掉那个反斜杠,一般的错误都在这里 xml文件：^([a-zA-Z]+-?)+[a-zA-Z0-9]+\.[x|X][m|M][l|L]$ 中文字符的正则表达式：[\u4e00-\u9fa5] 双字节字符：[^\x00-\xff] (包括汉字在内，可以用来计算字符串的长度(一个双字节字符长度计2，ASCII字符计1)) 空白行的正则表达式：\n\s*\r (可以用来删除空白行) HTML标记的正则表达式：&lt;(\S?)[^&gt;]&gt;.?&lt;/\1&gt;|&lt;.? /&gt; (网上流传的版本太糟糕，上面这个也仅仅能部分，对于复杂的嵌套标记依旧无能为力)S 首尾空白字符的正则表达式：^\s|\s$或(^\s)|(\s$) (可以用来删除行首行尾的空白字符(包括空格、制表符、换页符等等)，非常有用的表达式) 腾讯QQ号：[1-9][0-9]{4,} (腾讯QQ号从10000开始) 中国邮政编码：[1-9]\d{5}(?!\d) (中国邮政编码为6位数字) IP地址：\d+.\d+.\d+.\d+ (提取IP地址时有用) IP地址：((?:(?:25[0-5]|2[0-4]\d|[01]?\d?\d)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d?\d))]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux Filesystem]]></title>
      <url>%2F2017%2F03%2F28%2Ffilesystem%2F</url>
      <content type="text"><![CDATA[什么是Filesystem？Filesystem就是分区或磁盘上的所有文件的逻辑集合。它不仅包含着文件中的数据而且还有文件系统的结构，所有Linux用户和程序看到的软连接及文件保护信息等都存储在其中。 文件系统有多种类型： ext2：早期linux中常用的文件系统。 ext3：ext2的升级版，带日志功能。 RAMFS：内存文件系统，速度快。 iso9660：光盘或光盘镜像。 NFS：网络文件系统，当初由SUN发明，除妖用于远程文件共享; MS-DOS：MS-DOS文件系统。 FAT：Windows XP 操作系统采用的文件系统。 NTFS：Windows NT/XP 操作系统采用的文件系统。 目录与分区文件系统位于磁盘分区中，一个硬盘又可以有多个分区，也可以只有一个分区，一个分区只能包含一个文件系统。 Linux的文件结构是单个的树状结构，根目录是”/“，其他目录都要位于根目录下。 以下是/目录下的结构： 1234567891011121314151617181920212223/├── bin├── boot├── dev├── etc├── home├── lib├── lib64├── lost+found├── media├── misc├── mnt├── net├── opt├── proc├── root├── sbin├── selinux├── srv├── sys├── tmp├── usr└── var 具体说明： 目录 说明 / 根目录，只能包含目录，不能包含具体文件 /bin 存放可执行文件，很多命令就对应/bin目录下的某个程序，如：ls、cp、mkdir，/bin目录下对所有用户有效 /boot 存放与内核有关的文件 /dev device 设备文件 /etc 存放各种系统包括应用的配置文件 /home 每个用户的家目录，而且是每个用户默认的工作目录 /lib 程序包括系统所以来的一些共享库文件及内核所依赖的模块文件 /lib64 系统程序所依赖的库文件通常以.so结尾 lost+found 垃圾回收站 /media 光盘或者U盘挂载点，媒体介质挂载点 /misc 杂项，存放不好归类的文件 /mnt 临时文件挂载点 /net 网络配置文件 /opt 第三方应用的安装位置如：nginx，tomcat，Apache /proc 伪文件系统，记录系统硬件的一些运行信息 /sbin 存放管理类命令 /selinux 存放与linux相关的文件或记录 /srv 系统运行产生的一些文件 /sys 伪文件系统，记录系统硬件的一些运行信息 /tmp 杂项，临时文件以及应用产生的临时文件 /usr 二级层级存储用户的只读数据； 包含(多)用户主要的公共文件以及应用程序 /var 日志存放以及应用产生的一些文件或者临时文件 /usr与/var目录下常用的目录： 目录 说明 /usr/bin 非必要的命令二进制文件(在单用户模式中不需要用到的)；用于所有用户 /usr/include 标准的包含文件 /usr/lib 备用格式库(可选的) /usr/local 三级层次 用于本地数据，具体到该主机上的。通常会有下一个子目录, 比如, bin/, lib/, share/. /usr/local/sbin 非必要系统的二进制文件，比如用于不同网络服务的守护进程 /usr/share 架构无关的 (共享) 数据 /usr/src 源代码，比如内核源文件以及与它相关的头文件 — — /var/cache 应用程序缓存数据， 这些数据是由耗时的I/O(输入/输出)的或者是运算本地生成的结果。这些应用程序是可以重新生成或者恢复数据的。当没有数据丢失的时候，可以删除缓存文件 /var/lib 状态信息。这些信息随着程序的运行而不停地改变，比如，数据库，软件包系统的元数据等等 /var/lock 锁文件。这些文件用于跟踪正在使用的资源 /var/log 日志文件。包含各种日志。 /var/mail 内含用户邮箱的相关文件 /var/opt 来自附加包的各种数据都会存储在其中 /var/spool 该spool主要用于存放将要被处理的任务，比如打印队列以及邮件外发队列 /var/mail 过时的位置，用于放置用户邮箱文件 /var/tmp 存放重启后保留的临时文件 tree命令：用来查看目录结构123tree -L 1 -d /-L 指定层数-d 只查看目录 常用文件管理命令： 命令 说明 cat filename 查看文件内容。 cd dirname 改变所在目录。 cp file1 file2 复制文件或目录。 file filename 查看文件类型(binary, text, etc)。 find filename dir 搜索文件或目录。 head filename 显示文件的开头，与tail命令相对。 less filename 查看文件的全部内容，可以分页显示，比more命令要强大。 ls dirname 遍历目录下的文件或目录。 mkdir dirname 创建目录。 more filename 查看文件的全部内容，可以分页显示。 mv file1 file2 移动文件或重命名。 pwd 显示用户当前所在目录。 rm filename 删除文件。 rmdir dirname 删除目录。 tail filename 显示文件的结尾，与head命令相对。 touch filename 文件不存在时创建一个空文件，存在时修改文件时间戳。 whereis filename 查看文件所在位置。 which filename 如果文件在环境变量PATH中有定义，那么显示文件位置。 Linux的文件类型： - 普通文件 d directory 目录文件 b 块设备 blockc 字符设备 character l 符号链接文件 p 管道文件pipe 进程间通信可能会管道 s 套接字文件 socket 或多或少有点像sockets(套接字)，提供一个进程间的通信机制，而不用网络套接字协议。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[获取帮助]]></title>
      <url>%2F2017%2F03%2F25%2Fget-help%2F</url>
      <content type="text"><![CDATA[概要whatis COMMAND --help man/info 本地帮助文档/usr/share/doc 官网在线文档 Google 在Linux中获取帮助有这么几方面 whatis COMMAND --help man/info 本地帮助文档/usr/share/doc 官网在线文档 Google whatis显示命令的简短描述 每晚使用一个数据库更新 刚安装后不可立即使用 makewhatis | mandb 制作数据库 123456[root@pxe57 ~]# whatis calcal (1) - displays a calendarcal (1p) - print a calendar[root@pxe57 ~]# man -f calcal (1) - displays a calendarcal (1p) - print a calendar 内部命令：help COMMAND man bash 外部命令：(1) # COMMAND --help # COMMAND -h (2) 使用手册(manual) # man COMMAND (3) 信息页 # info COMMAND (4) 程序自身的帮助文档 README INSTALL ChangeLog (5) 程序官方文档 官方站点： Documentation (6) 发行版的官方文档 (7) Googl help显示用法总结和参数列表 $ date --help 用法: date [OPTION]... [+FORMAT] date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]] [] 表示可选项 ... 表示有多个选项 | 表示或 eg：a|b|c|=表示a或b或c {} 表示分组 infoman常用于命令参考 ， GNU工具info适合通用文档参考。 没有参数,列出所有的页面 info 页面的结构就像一个网站 每一页分为“ 节点” 链接节点之前 * info [ 命令 ] 导航info页：方向键， PgUp， PgDn 导航 Tab键 移动到下一个链接 d 显示主题目录 Home 显示主题首部 Enter进入 选定链接 n/p/u/l 进入下/前/上一层/最后一个链接 s 文字 文本搜索 q 退出 info 通过本地文档获取帮助：System-&gt;help（ centos6） Applications -&gt; documentation-&gt;help（ centos7）提供的官方使用指南和发行注记 /usr/share/doc目录 多数安装了的软件包的子目录,包括了这些软件的相关原理说明 常见文档： README INSTALL CHANGES 不适合其它地方的文档的位置 配置文件范例 HTML/PDF/PS 格式的文档 授权书详情 通过在线文档获取帮助：第三方程序官方文档 http://www.nginx.org http://tomcat.apache.org http://httpd.apache.org http://www.python.org 通过发行版官方的文档光盘或网站可以获得 安装指南、 部署指南、 虚拟化指南等 红帽知识库和官方在线文档 http://kbase.redhat.com http://www.redhat.com/docs http://access.redhat.com 网站搜索：http://tldp.org http://www.slideshare.net http://www.google.com Openstack filetype:pdf rhca site:redhat.com/docs]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[bash 快捷键]]></title>
      <url>%2F2017%2F03%2F25%2Fbash-kuaijie%2F</url>
      <content type="text"><![CDATA[bash快捷键Ctrl + l 清屏， 相当于clear命令 Ctrl + o 执行当前命令， 并重新显示本命令 Ctrl + s 阻止屏幕输出， 锁定 Ctrl + q 允许屏幕输出 Ctrl + c 终止命令 Ctrl + z 挂起命令 Ctrl + a 光标移到命令行首， 相当于Home Ctrl + e 光标移到命令行尾， 相当于End Ctrl + f 光标向右移动一个字符 Ctrl + b 光标向左移动一个字符 Alt + f 光标向右移动一个单词尾 Alt + b 光标向左移动一个单词首 Ctrl + xx 光标在命令行首和光标之间移动 Ctrl + u 从光标处删除至命令行首 Ctrl + k 从光标处删除至命令行尾 Ctrl + w 从光标处向左删除至单词首 Alt + d 从光标处向右删除至单词尾 Ctrl + d 删除光标处的一个字符 Ctrl + h 删除光标前的一个字符 Ctrl + y 将删除的字符粘贴至光标后 Alt + c 从光标处开始向右更改为首字母大写的单词 Alt + u 从光标处开始向右更改为全部大写的单词 Alt + l 从光标处更改为全部小写的单词 Ctrl + t 交换光标处和之前的字符位置 Alt + t 交换光标处和之前的单词位置 Alt + N 提示输入指定字符后， 重复显示该字符N次 注意： Alt组合快捷键经常和其它软件冲突]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[命令行扩展]]></title>
      <url>%2F2017%2F03%2F25%2Fcommand-kuozhan%2F</url>
      <content type="text"><![CDATA[命令行扩展$()或$ 把一个命令的输出打印给另一个命令的参数 $ echo &quot;This system&apos;s name is $(hostname) &quot; This system&apos;s name is server1.example.com $echo &quot;i am `whoami` &quot; i am root 括号扩展： { } 打印重复字符串的简化形式12[root@pxe57 ~]# echo file&#123;1,3,5&#125;file1 file3 file5 12[root@pxe57 ~]# echo &#123;1..10&#125;1 2 3 4 5 6 7 8 9 10 12[root@pxe57 ~]# echo &#123;a..z&#125;a b c d e f g h i j k l m n o p q r s t u v w x y z 12[root@pxe57 ~]# echo &#123;000..20..2&#125;000 002 004 006 008 010 012 014 016 018 020 命令补全 bash根据PATH环境变量定义的路径，自左而右在每个路径搜寻以给定命令 名命名的文件， 第一次找到的命令即为要执行的命令. 用户给定的字符串只有一条惟一对应的命令， 直接补全否则， 再次Tab会给出列表 路径补全 把用户给出的字符串当做路径开头，并在其指定上级目录下搜索以指定的字符串开头的文件名 如果惟一： 则直接补全 否则： 再次Tab给出列表 TAB快捷键 command 2Tab 所有命令行补全 string2Tab 以string开头命令 /2Tab 显示所有根目录下一级目录， 包括隐藏目录 ./2Tab 当前目录下子目录， 包括隐藏目录 *2Tab 当前目录下子目录， 不包括隐藏目录 ~2Tab 所有用户列表 $2Tab 所有变量 @2Tab /etc/hosts记录 （ centos7不支持） =2Tab 相当于ls –A]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[date 命令]]></title>
      <url>%2F2017%2F03%2F25%2Fdate%2F</url>
      <content type="text"><![CDATA[NAME 名称 date date - print or set the system date and time 显示系统的时间和日期。 也可以用来显示或设定系统的日期与时间。 SYNOPSIS 概要 用法 date [OPTION]... [+FORMAT] date [-u|--utc|--universal] [MMDDhhmm[[CC]YY][.ss]] 选项 %y : 年份的最后两位数字 (00.99) %Y : 完整年份 (0000-9999) %m : 月份 (01-12) %b : 月份 (Jan-Dec) %B : 月份 (January-December) %c : 直接显示日期与时间 %d : 日 (01-31) %H : 小时(00-23) %M : 分钟(00-59) %p : 显示本地 AM 或 PM %S : 秒(00-60) %T : 直接显示时间 (24 小时制) %X : 相当于 %H:%M:%S %x : 直接显示日期 (mm/dd/yy) %a : 星期几 (Sun-Sat) %D : 直接显示日期 (mm/dd/yy) %j : 一年中的第几天 (001-366) %U : 一年中的第几周 (00-53) (以 Sunday 为一周的第一天的情形) %w : 一周中的第几天 (0-6) %W : 一年中的第几周 (00-53) (以 Monday 为一周的第一天的情形) 示例 123date [root@localhost ~]# dateSat Mar 25 12:34:40 CST 2017 123456789date -s 修改系统日期[root@localhost ~]# date -s &quot;20170630&quot;Fri Jun 30 00:00:00 CST 2017修改系统时间[root@pxe57 ~]# date -s &quot;20170325 1430&quot;Sat Mar 25 14:30:00 CST 2017 12345date +%Y/%m/%d改变日期显示格式[root@pxe57 ~]# date +%Y/%m/%d2017/03/25 显示日历：如果要列出目前这个月份可以直接执行cal。 [root@pxe57 ~]# cal March 2017 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 显示全年日历[root@pxe57 ~]# cal -y 2017 January February March Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 1 2 3 4 1 2 3 4 8 9 10 11 12 13 14 5 6 7 8 9 10 11 5 6 7 8 9 10 11 15 16 17 18 19 20 21 12 13 14 15 16 17 18 12 13 14 15 16 17 18 22 23 24 25 26 27 28 19 20 21 22 23 24 25 19 20 21 22 23 24 25 29 30 31 26 27 28 26 27 28 29 30 31 April May June Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa 1 1 2 3 4 5 6 1 2 3 2 3 4 5 6 7 8 7 8 9 10 11 12 13 4 5 6 7 8 9 10 9 10 11 12 13 14 15 14 15 16 17 18 19 20 11 12 13 14 15 16 17 16 17 18 19 20 21 22 21 22 23 24 25 26 27 18 19 20 21 22 23 24 23 24 25 26 27 28 29 28 29 30 31 25 26 27 28 29 30 30 July August September Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa 1 1 2 3 4 5 1 2 2 3 4 5 6 7 8 6 7 8 9 10 11 12 3 4 5 6 7 8 9 9 10 11 12 13 14 15 13 14 15 16 17 18 19 10 11 12 13 14 15 16 16 17 18 19 20 21 22 20 21 22 23 24 25 26 17 18 19 20 21 22 23 23 24 25 26 27 28 29 27 28 29 30 31 24 25 26 27 28 29 30 30 31 October November December Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 1 2 3 4 1 2 8 9 10 11 12 13 14 5 6 7 8 9 10 11 3 4 5 6 7 8 9 15 16 17 18 19 20 21 12 13 14 15 16 17 18 10 11 12 13 14 15 16 22 23 24 25 26 27 28 19 20 21 22 23 24 25 17 18 19 20 21 22 23 29 30 31 26 27 28 29 30 24 25 26 27 28 29 30 31 显示指定月份日历 [root@pxe57 ~]# cal 03 2017 March 2017 Su Mo Tu We Th Fr Sa 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[echo 命令]]></title>
      <url>%2F2017%2F03%2F25%2Fecho%2F</url>
      <content type="text"><![CDATA[ECHONAME 名称 echo - display a line of text echo - 在屏幕上显示一段文字 SYNOPSIS 概要 echo [SHORT-OPTION]... [STRING]... echo [短选项]... [字符串] echo LONG-OPTION echo 长选项 DESCRIPTION 描述 Echo the STRING(s) to standard output. Echo是字符的标准输出 -n do not output the trailing newline 输出时不自动换行 -e enable interpretation of backslash escapes 启用\字符功能 -E disable interpretation of backslash escapes （默认）不支持\解释功能 (default) If -e is in effect, the following sequences are rec-ognized: 启用命令选项-e，若字符串中出现以下字符， 则特别加以处理， 而不会将它当成一般文字输出 \\ backslash 插入\字符 \a alert (BEL) 发出警告声 \b backspace 向前删除一个字符 \c produce no further output 最后不加换行符号 \f form feed 换行但光标仍旧停留在原来的位置 \n new line 换行且光标移至行首 \r carriage return 回车，即光标移至行首 \t horizontal tab 插入tab \v vertical tab 垂直插入tab，与\f显示相同 \0NNN byte with octal value NNN (1 to 3 digits) 插入（nnn）八进制所代表的ASCII字符； /bin/echo --help 查看help帮助 /bin/echo --version 查看当前版本echo版本 示例 123echo abcdefghijklmnopqrstuvwxyz[root@localhost ~]# echo abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz 123echo -n [root@localhost ~]# echo -n abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz[root@localhost ~]# 123echo -e \\[root@localhost ~]# echo -e &quot;\\ abcdefghijklmnopqrstuvwxyz&quot;\ abcdefghijklmnopqrstuvwxyz 123echo -e \b[root@localhost ~]# echo -e &quot;abcdefghijklmnopqrstuvwxy\bz&quot;abcdefghijklmnopqrstuvwxz 123echo -e \c[root@localhost ~]# echo -e &quot;abcdefghijklmnopqrstuvwxyz\c&quot;abcdefghijklmnopqrstuvwxyz[root@localhost ~]# 1234echo -e \f[root@localhost ~]# echo -e &quot;abcd\fefghijklmnopqrstuvwxyz&quot;abcd efghijklmnopqrstuvwxyz 1234echo -e \n[root@localhost ~]# echo -e &quot;\nabcdefghijklmnopqrstuvwxyz&quot;abcdefghijklmnopqrstuvwxyz]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Linux 基础]]></title>
      <url>%2F2017%2F03%2F24%2FLinux%2F</url>
      <content type="text"><![CDATA[Linux中的用户 在Linux中一般分为两个用户： root用户：一个特殊的管理账户，也被称为超级用户，在Windows中相当于administrato管理&gt;员。root已接近完整的系统控制，对系统损害几乎有无限的能力，在平时的生产环境中，除非需要做特定的操作，否则一般情况下不在root用户下对系统进行操作。 普通用户： 普通用户也叫非特权用户，它对系统操作的权限有限，所以普通用户的操作对操作系统造成的损害的能力也比较有限。 用户登录信息查看命令：123whoami: 显示当前登录有效用户who: 系统当前所有的登录会话w: 系统当前所有的登录会话及所做的操作 终端 终端： 终端分为设备终端，物理终端，虚拟终端，图形终端，串行终端，伪终端。 设备终端： 键盘鼠标显示器。 物理终端： 在(/dev/console) 下，控制台console。 虚拟终端：（tty：tele type writers，/dev/tty# #为[1-6] ） 在(/dev/tty）下，tty可以有多个，可以使用Ctrl+Alt+F[1-6] 来进行切换。 图形终端：(/dec/tty7) startx，xwindows 在(/dec/tty7)下， 在CentOS6中：启动图形终端为Ctrl+Alt+F7。 在CentOS7中：启动图形终端为：在哪个终端启动就为于哪个终端。 串行终端： 在(/dev/ttyS#)下，使用串行接口输出的终端设备。 伪终端：（pty：pseudo-tty ，/dev/pts/#） 在(/dev/pts/#)下,pts,SSH远程连接；使用Xshell或CRT进行远程连接的都称为伪终端。 查看当前的终端设备： [root@localhost ~]# tty /dev/pts/0 交互式接口 交互式接口： 在启动终端后，在终端设备附加一个交互式应用程序，其实就是选择桌面或者是黑屏代码模式。 交互式程序： 交互式程序分为两类：GUI和CLI； GUI：Graphic User Interface图形用户界面，又称图形用户接口。 Xprotocol，window manager，desktop Desktop： GNOME（c语言编写，图形库gtk） KDE（c++编写，图形库qt） XFCE（c语言编写，图形库gtk+） CLI：Command Line Interface命令行界面，又称命令行接口。 shell程序：sh，csh，tcsh，ksh，bash，zsh SHELL Shell是一种高级程序设计语言，它是Linux系统的用户界面，为提供用户与内核进行交互操作的一种接口，他接受用户输入的命令并把它送入内核去执行，shell也被称为Linux的命令解释器（Command interpreter）。 BASH SHELL GNU Bourne-Again Shell（bash）是GNU计划中重要的工具软件之一，目前也是Linux标准的shell，与sh兼容。 CentOS中默认使用的是bash。 显示当前使用的shell：12[root@localhost ~]# echo $SHELL/bin/bash 显示当前系统使用的所有shell：12345678910 [root@localhost ~]# cat /etc/shells /bin/sh /bin/bash /sbin/nologin /usr/bin/sh /usr/bin/bash /usr/sbin/nologin /bin/tcsh /bin/csh` 命令提示符 [root@localhost ~]# #：当前用户为管理员 [lee@localhost root]$ $：当前用户为普通用户 显示提示符格式： [lee@localhost root]$ echo $PS1 [\u@\h \W]\$ PS1=”[\e[31m][\u@\h \W]\$[\e[0m]“12345678910\e\033 修改命令符颜色\u 当前用户\h 主机名简称 \H 主机名\w 当前工作目录 \W 当前工作目录基名\t 24小时时间格式 \T 12小时时间格式\! 命令历史数 \# 开机后命令历史数 执行命令 输入命令后回车： 提请shell程序找到键入命令所对应的可执行程序或代码，并由其分析后提交给内核分配资源将其运行起来。 在shell中可执行的命令有两类： 内部命令，外部命令 内部命令： 由shell自带的，而且通过某命令形式提供。 help：内部命令列表。 enable cmd：可以启用。 enable -n cmd：禁用内部命令。 enable -n：查看所有禁用的内部命令。 外部命令： 在文件系统路径下有对应的可执行程序文件。 查看路径： which -a，which --skip-alias，whereis 区别指定的命令是内部的还是外部的： [lee@localhost root]$ type cd cd is a shell builtin 内部命令 [lee@localhost root]$ type ll ll is aliased to `ls -l --color=auto&apos; 外部命令 在文件系统路径下有对应的可执行程序文件。 查看路径： which -a，which --skip-alias，whereis 区别指定的命令是内部的还是外部的： [lee@localhost root]$ type cd cd is a shell builtin 内部命令 [lee@localhost root]$ type ll ll is aliased to `ls -l --color=auto&apos; 外部命令 Hash缓存表 系统初始hash表为空，当外部命令执行时，默认会从PATH路径下寻找该命令，找到后会将这条命令路径记录到hash表中，当再次使用该命令时，shell解释器首先会查看hash表，存在将执行，如果不存在，将会去PATH路径下寻找。利用hash缓存表可大大提高命令的调用速率。 Hash常见用法： hash：显示hash缓存。 hash -l：显示hash缓存，可作为输入使用。 hash -p path name：将命令全路径path起别名为name。 hash -t name：打印缓存中的name的路径。 hash -d name ：清除name的缓存。 hash -r ：清除缓存。 别名 命令别名：123456789101112显示当前shell进程所有可用的命令别名： [root@localhost ~]# alias alias cp=&apos;cp -i&apos; alias egrep=&apos;egrep --color=auto&apos; alias fgrep=&apos;fgrep --color=auto&apos; alias grep=&apos;grep --color=auto&apos; alias l.=&apos;ls -d .* --color=auto&apos; alias ll=&apos;ls -l --color=auto&apos; alias ls=&apos;ls --color=auto&apos; alias mv=&apos;mv -i&apos; alias rm=&apos;rm -i&apos; alias which=&apos;alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde&apos; 定义别名：12345定义别名name，其相当于执行命令VALUE：[root@localhost ~]# alias lqb=&apos;ls -a&apos;[root@localhost ~]# lqb. anaconda-ks.cfg .bash_logout .bashrc .config .ssh .Xauthority.. .bash_history .bash_profile .cache .cshrc .tcshrc 在命令行中定义的别名，仅对当前shell进程有效，如果想永久保存要定义在配置文件中：12仅对当前用户有效：~/.bashrc 对所有用户有效：. /etc/bashrc 编辑配置给出的新配置不会立即生效 bash进程重新读取配置文件12source /path/to/config_file./path/to/config_file 撤销别名：unalias12345 unalias [-a] name [name ...] -a 取消所有别名[root@localhost ~]# unalias lqb[root@localhost ~]# lqbbash: lqb: command not found 如果别名同原命令同名， 如果要执行原命令， 可使用:123“\COMMAND”’COMMAND’/PATH/COMMAND： 外部命令 命令行格式 12345 COMMAND [OPTIONS...] [ARGUMENTS...]选项： 用于启用或关闭命令的某个或某些功能；短选项： -c, 例如： -l, -h长选项： --word， 例如： --all, --human-readable参数： 命令的作用对象， 比如文件名， 用户名等 注意： 1.多选项，以及多参数和命令之间使用空白字符分隔 2.取消和结束命令执行： Ctrl+c，Ctrl+d 3.多个命令可以用；符号分开 4.一个命令可以用\分成多行 date：显示日期和时间 Linux的两种时钟： 系统时钟： 由Linux内核通过CPU的工作频率进行的 硬件时钟： 主板 hwclock， clock: 显示硬件时钟 -s, --hctosys 以硬件时钟为准， 校正系统时钟 -w, --systohc 以系统时钟为准， 校正硬件时钟 时区： /etc/localtime cal： 显示日历 cal –y：显示全年日历 开机关机 关机：1halt, poweroff 重启：123reboot-f: 强制， 不调用shutdown-p: 切断电源 关机或重启:shutdown1234567shutdown [OPTION]... TIME [MESSAGE]-r: reboot-h: halt-c： cancelTIME:now: 立刻+m: 相对时间表示法， 多久之后； 例如 +3hh:mm: 绝对时间表示， 指明具体时间 screen命令 1234567891011121314创建新screen会话： screen –S [SESSION]加入screen会话： screen –x [SESSION]离线某个会话： screen –d [SESSION]恢复某screen会话： screen -r [SESSION]退出并关闭screen会话 ： exit剥离当前screen会话： Ctrl+a,d显示所有已经打开的screen会话： screen -l echo命令 123功能： 显示字符语法： echo [-neE][字符串]说明： echo会将输入的字符串送往标准输出。 输出的字符串间以空白字符隔开, 并在最后加上换行号 选项：1234567891011121314151617&gt;-E （ 默认） 不支持 \ 解释功能-n 不自动换行-e 启用 \ 字符的解释功能 显示变量： echo &quot;$VAR_NAME“ 变量会替换， 弱引用 echo &apos;$VAR_NAME‘ 变量不会替换， 强引用 启用命令选项-e， 若字符串中出现以下字符， 则特别加以处理， 而不会将它当成一般文字输出\a 发出警告声\b 退格键\c 最后不加上换行符号\n 换行且光标移至行首\r 回车， 即光标移至行首， 但不换行\t 插入tab\\ 插入\字符\0nnn 插入nnn（ 八进制） 所代表的ASCII字符echo -e &apos;\033[43;31;5mmagedu\033[0m&apos;\xHH插入HH（ 十六进制） 所代表的ASCII字]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F03%2F14%2Fhello-world%2F</url>
      <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
    </entry>

    
  
  
</search>
